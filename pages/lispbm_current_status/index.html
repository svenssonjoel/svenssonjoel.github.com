<HTML>

<HEAD>  

  <TITLE>Another Lisp for Microcontrollers</TITLE>

  <meta charset="UTF-8">
  <meta name="description" content="A quick walkthrough of the lispBM implementation">
  <meta name="keywords" content="Lisp stm32 nrf52 stm32f4 microcontroller mcu evaluation continuation passing style xilinx zynq ">
  <meta name="author" content="Bo Joel Svensson">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <script data-ad-client="ca-pub-6663189426712847" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  <!-- Global site tag (gtag.js) - Google Analytics -->

  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111281599-1"></script>

  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    
    gtag('config', 'UA-111281599-1');
  </script>

  <link rel="canonical" href="https://svenssonjoel.github.io/pages/lispbm_current_status/index.html" />

</HEAD> 

<style type="text/css">
  
  body, html {
  margin-left: 5%;
  margin-right: 5%;
  }
  
  
  .topnav {
  overflow: auto;
  white-space: nowrap;
  background-color: #333;
  }
  
  .topnav a {
  display: inline-block;
  color: #f2f2f2;
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
  font-size: 17px;
  }
  
  .topnav a:hover {
  background-color: #ddd;
  color: black;
  }
  
  .topnav a.active {
  background-color: #4CAF50;
  color: white;
  }
  
  
  .hero-image {
  background-image: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url("../../images/nerd.jpg");
  height: 50%;  
  /* Position and center the image to scale nicely on all screens */
  background-position: center;
  background-repeat: no-repeat;
  background-size: cover;
  position: relative;
  }

  /* Place text in the middle of the image */
  .hero-text {
  text-align: center;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: gray;
  }
  
  
  
  body, html {
  margin-left: 5%;
  margin-right: 5%;
  font-size: large;
  zoom-level: 150%;
  }
  
  pre {
  background-color: white;
  word-wrap: normal;
  overflow-x: auto;
  white-space: pre;
  margin-left: 2%;
  margin-right: 2%;
  }

  img {
  max-width:100%;
  height:auto;
  }
  
  .yt-link {
  text-align: center;
  }
  
  .yt-link img {
  display: block;
  margin: 0 auto;
  max-width: 100%
  }

  tr:hover {background-color: #8abd8a;}
  

  th {
  background-color: #333;
  color: white;
  }
  
</style>

<BODY bgcolor=#C0C0C0>

<div class="hero-image">
 <div class="hero-text">
   <h1>BLOG</h1>
 </div>
</div>   

<div class="topnav">
  <a href="../../index.html"> Home </a>
  <a href="../../index.html#BLOG"> Blog </a>
  <a href="../../index.html#VIDEOS"> Videos </a>   
  <a href="../../research.html"> Research </a>
  <a href="../../about.html"> About </a>
  <a href="../../privacy_policy.html">Privacy Policy</a>
</div>

<!-- BODY IS INTENTIONALY LEFT OPEN --> 

<h1 id="another-lisp-for-microcontrollers">Another Lisp for Microcontrollers</h1>
<p>For a while now, not too long, couple of years or so, I have been working in the vicinity of microcontrollers (MCUs). I don't have a whole lot of experience in low-level programming of devices like the <a href="https://www.st.com/en/evaluation-tools/stm32-discovery-kits.html">STM32</a> , the <a href="https://www.nordicsemi.com/Products/Low-power-short-range-wireless/nRF52833/GetStarted">NRF52</a> or the ARM Cortex A9 of the Xilinx Zynq chip on the <a href="https://shop.trenz-electronic.de/en/TE0726-03M-ZynqBerry-Module-with-Xilinx-Zynq-7010-in-Raspberry-Pi-Form-Faktor">Trenz ZynqBerry</a>. But I do enjoy learning about them, <strong>slowly</strong>. The Code in C, Cross-compile, Flash and Debug loop (CCFDL?) is a bit heavy though. Wouldn't it be nice with a REPL (Read, Evaluate and Print Loop)?</p>
<p>The <a href="https://www.youtube.com/watch?v=-J_xL4IGhJA&amp;list=PLE18841CABEA24090">MIT 6.001 Structure and Interpretation of Computer Programs</a> series of lectures is a lot of fun and I recommend everyone to watch it. I watched this lecture series several times while entertaining the idea of some day implement some kind of a Lisp. However, I didn't want to implement a Lisp interpreter in Lisp, or even in Haskell, it would feel a bit like cheating. So instead, the idea is to combine these two newly found interests (MCUs and Lisps).</p>
<p>The <a href="https://github.com/svenssonjoel/lispBM">lispBM</a> project is my (ongoing) attempt to learn some about lisp while at the same time learn more about MCUs and to make them more accessible to me, once you get used to having a REPL it is hard to go back.</p>
<p>I don't have very much experience or long background in programming numerous Lisps, so my attempt of making one is most likely very naive. A small amount of dabbling with <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/">Emacs Lisp</a> and I did like skimming <a href="https://nostarch.com/lisp.htm">Land Of Lisp</a> but navigating the jungle of Lisp dialects is not where I am at. This means that lispBM is not going to adhere to any standard or be a real <em>Scheme</em> or <em>CL</em>, to me that does not matter!</p>
<p>Now I know that there are many other MCU-lisps. I have tried not to peek at the insides of these at all. But I looked at <a href="http://lisperator.net/pltut/">Lisperator</a> for some tips with the evaluator, I would definitely recommend this tutorial. I have probably stared at the tail-call optimizing evaluator at Lisperator for hours trying to understand what is going on there. I am not going to pretend that I fully understand it yet. Early on I used the <a href="https://github.com/orangeduck/mpc">MPC</a> Micro Parser Combinators for parsing expressions. This is the same parser generator code that is used in <a href="http://www.buildyourownlisp.com/">BuidYourOwnLisp</a>. However, when going towards smaller MCUs (with less than 256k of RAM) the MPC library showed to be a bit to hungry on memory and I had to hack something up (more about that in the section about parsing).</p>
<p>Here is a list of other Lisp-on-odd-hardware projects:</p>
<ol>
<li><a href="https://dmitryfrank.com/articles/lisp_on_mcu">Let's Run Lisp on Microcontrollers.</a></li>
<li><a href="http://www.ulisp.com/">uLisp.</a></li>
<li><a href="http://www.yuasa.kuis.kyoto-u.ac.jp/~yuasa/xs/">XS.</a></li>
<li><a href="https://github.com/yesco/esp-lisp">esp-lisp.</a></li>
</ol>
<p>I'm sure there are more examples! please let me know what you are working on.</p>
<p>If you want to see lispBM in action, check out the video <a href="https://youtu.be/OeQ161G_Kgs">LISPBM on NRF52</a> or the video that goes over what went into porting it to NRF52 <a href="https://youtu.be/cXSavxC3th0">LISPBM Porting to NRF52</a>.</p>
<p>LispBM is written in C, compiles with -std=c11 flag, for 32bit platforms. So far it has been tried out on x86 (with -m32 flag and depending on something like multilib if you are on a 64bit platform), ARM Cortex M4 (the STM32F4 MCU), ARM Cortex M4 (the NRF52 MCU) and ARM Cortex A9 (The Xilinx Zynq 7000). When deploying lispBM on an MCU it helps a lot to have access to a <em>Hardware Abstraction Layer</em>, HAL. So far lispBM has been compiled into code based on <a href="http://chibios.org/dokuwiki/doku.php">ChibiOs</a> and <a href="https://www.zephyrproject.org/">ZephyrOs</a> both providing a lot of HAL functionality. LispBM has also been tried on the ARM A9 core of the Xilinx Zynq 7000 here depending on the HAL that is provided with the Xilinx toolchain.</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<!-- horizontal unit -->

<p><ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-6663189426712847"
data-ad-slot="2225439322"
data-ad-format="auto"
data-full-width-responsive="true"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h2 id="a-few-thoughts-on-lisp">A Few Thoughts on Lisp</h2>
<p>The series of MIT video lectures showed a simple elegance and really made me want to try making some kind of a Lisp. If you just get over the strange "prefix" notation where <code>(+ 1 2)</code> means <code>(1 + 2)</code> and instead focus on the really cool part that <code>(+ 1 2)</code> is actually exactly what the expression looks like loaded into memory (the Lisp heap) and that it extends to <em>N</em> arguments <code>(+ 1 2 3 4)</code>. When I say that <code>(+ 1 2)</code> is exactly what it looks like in memory, what I mean is that it is stored as a linked list where the first element is the <em>symbol</em> <code>+</code> and the second and third elements of the list are the <em>values</em> <code>1</code> and <code>2</code>. The elements and pointers to the next cell are stored in what is called <em>cons cells</em>. a cons cell consists of enough bytes of memory to hold two pointers or two values or some two element permutation of pointer and value (many of the details of this as implemented in lispBM can be found later in this text). In more detail then, the expression <code>(+ 1 2)</code> will in memory be made up out of a first cons cell containing <code>+</code> in its first position (or car) and a pointer to the next cell in its second (cdr) position. Likewise, the next cell contains the <code>1</code> in the car position and a pointer to the next cell in the cdr. The last cell in the linked up structure of cons cells contains a <code>2</code> in car and a special symbol called <code>nil</code> in the cdr position to terminate the list.</p>
<p><img src="./media/cons_cell.png" title="Cons cell" alt="Cons cell" /></p>
<p>Now, if we give <code>(+ 1 2)</code> to a Lisp interpreter, it will evaluate it and arrive at the answer <code>3</code>. The first stage in this, though, is to read the string <code>(+ 1 2)</code> into the heap (generating the linked list of symbols and values), this is called <em>Reading</em>. Following that the lisp interpreter will start to consume the linked list to reduce it to an answer, called <em>evaluating</em>. Finally the result is <em>printed</em>. This is what a <em>REPL</em> does, it reads, evaluates and prints and then it does it all again.</p>
<p><img src="./media/read_eval0.png" title="Read and Evaluate" alt="Read evaluate" /></p>
<p>If giving the lisp interpreter a list (such as <code>(+ 1 2)</code>) it will be assumed to mean "add 1 and 2", so how does one actually create a list <em>of data</em>? Giving the list <code>(1 2 3)</code> to the interpreter will not work. The interpreter always treats a list given to it in this way as an application of the <em>function</em> represented by the first element to the rest of the elements. So doing that will give some kind of an error message. There is, However, an operator that tells the interpreter not to evaluate its argument, this operator is called <em>quote</em> and is written <code>'</code> as in for example <code>'(1 2 3)</code>. So when you give the expression <code>'(1 2 3)</code> to the REPL, it will reply with <code>(1 2 3)</code>. We have created a list. It is also possible to give the expression <code>'(+ 1 2)</code> to the REPL and this will result in a linked list in memory consisting of elements <code>+</code>, <code>1</code> and <code>2</code>. The REPL will now give <code>(+ 1 2)</code> as the output result of your computation. There is an operation with the reversed meaning as well called <code>eval</code> that means "do evaluate this". As an example the expression <code>(eval '(+ 1 2))</code> given to the REPL again results in it printing out the answer <code>3</code>. Together <code>'</code> and <code>eval</code> are very powerful, it means we can construct code <strong>on the fly</strong> in memory and then have the interpreter compute the result.</p>
<p>Using <code>'</code> to create a list works well in some simple cases like above. A more down-to-earth way to create a list is to use the <code>list</code> function.</p>
<pre><code># (list (+ 1 2) (+ 3 4) (+ 5 6))
&gt; (3 (7 (11 nil)))
</code></pre>
<p>If trying to use <code>'</code> in this case the result would be:</p>
<pre><code># &#39;((+ 1 2) (+ 3 4) (+ 5 6))
&gt; ((+ (1 (2 nil))) ((+ (3 (4 nil))) ((+ (5 (6 nil))) nil)))
</code></pre>
<p>So the difference here is that with <code>list</code> each element is evaluated and what <code>'</code> really does is to just give back its argument unevaluated. So To make lists, in general, use <code>list</code>, even though <code>'</code> can be used in some cases (such as <code>'(1 2 3)</code>).</p>
<p><img src="./media/read_eval_quoted.png" title="Read and evaluate a
quoted expression" alt="Read eval qouted" /></p>
<p>In the paragraphs above there are a couple of words that I emphasized without much explanation. These are words that (as I understand it) are part of the Lisp vocabulary. The heap consists of cons cells, only large enough to hold two pointers or values (or mix there-of) so a symbol (such as <code>+</code>) also has to be represented by a number no larger than a pointer in number of bits. This means that values (characters, signed or unsigned integers), symbols, pointers all can appear on either car or cdr part of a cell. To tell them apart a couple of bits are sacrificed. I will go into the details about this in the section about the heap below.</p>
<h2 id="introducing-the-lispbm-language-constructs">Introducing the LispBM Language constructs</h2>
<p>Before going into the implementation details, I want to give a few examples of lispBM code in order to introduce many of the concepts that we will see again in the following sections.</p>
<p>When starting up the example REPL from the lispBM github repository you see something like this:</p>
<pre><code>Symrepr initialized.
Heap initialized. Heap size: 0.015625 MiB. Free cons cells: 2048
Evaluator initialized.
Extension added.
Lisp REPL started!
Type :quit to exit.
     :info for statistics.
# 
</code></pre>
<p>It shows a prompt where you can type in your lisp expressions or you can type <code>:info</code> for some statistics and information about the current state of the runtime system:</p>
<pre><code># :info
############################################################
Used cons cells: 402
ENV: ((foldl (closure ((f (i (xs nil))) ((if ((= (xs (nil nil))) ...
Allocated arrays: 0
GC counter: 0
Recovered: 0
Recovered arrays: 0
Marked: 0
Free cons cells: 1646
############################################################
#
</code></pre>
<p>This information will show how much of the heap is in use currently and how much is free, how many times garbage collection has been executed and so on. <code>ENV</code> refers to the contents of the environment that will be touched upon shortly in this section.</p>
<p>Now let's explore some of the basic functionality of this REPL.</p>
<h3 id="cons-car-and-cdr"><code>cons</code>, <code>car</code> and <code>cdr</code></h3>
<p>The <code>cons</code> function is used to construct. What it constructs are cons cells.</p>
<pre><code># (cons 1 2)
&gt; (1 2)
</code></pre>
<p><code>cons</code> takes two arguments and returns a pair. Used like this, with two values, <code>cons</code> allocates a cons cell from the heap and puts the values in the car and cdr position of that cell. This is not the same as evaluating <code>'(1 2)</code></p>
<pre><code># &#39;(1 2)
&gt; (1 (2 nil))
</code></pre>
<p><img src="./media/cons_heap.png" title="Cons and heap representations" alt="Cons and heap representations" /></p>
<p>It is a little bit unfortunate that lispBM is printing the result of <code>(cons 1 2)</code> as <code>(1 2)</code>. As I understand it, it is common to print this heap structure as <code>(1 . 2)</code> and call it a dotted pair. LispBM does not recognize dotted pairs in reading or uses them in output, should add this to the todo-list.</p>
<p>The <code>car</code> and <code>cdr</code> functions break things apart.</p>
<pre><code># (car (cons 1 2))
&gt; 1
# (cdr (cons 1 2))
&gt; 2

</code></pre>
<p><img src="./media/car_cdr.png" title="Car and cdr" alt="Car and cdr" /></p>
<h3 id="if"><code>if</code></h3>
<p>The conditional <code>if</code> takes three arguments, the first should be something that evaluates to true <code>t</code> or <code>nil</code> for false. The next two arguments are the expressions to evaluate on the <em>then</em> or <em>else</em> branch.</p>
<pre><code># (if &#39;t 1 2)
&gt; 1
# (if &#39;nil 1 2)
&gt; 2
</code></pre>
<h3 id="define"><code>define</code></h3>
<p><code>define</code> is used to add things to a global environment.</p>
<pre><code># (define apa 1)
&gt; t
</code></pre>
<p>This function application adds an entry into the environment that states that <code>apa</code> is defined to <code>1</code>. Typing <code>:info</code> in the REPL should show this mapping.</p>
<pre><code># :info
############################################################
Used cons cells: 547
ENV: ((apa 1) ((foldl (closure ((f (i (xs nil))) ((if ((= (xs (nil nil))) ...
Allocated arrays: 0
GC counter: 0
Recovered: 0
Recovered arrays: 0
Marked: 0
Free cons cells: 1501
############################################################

</code></pre>
<p>After defining <code>apa</code> to be 1 this is what it will evaluate to.</p>
<pre><code># apa
&gt; 1
# (+ 10 apa)
&gt; 11
#
</code></pre>
<h3 id="let"><code>let</code></h3>
<p><code>let</code> is used to bind a variable (symbol) to a value locally. It takes two arguments where the first is a list of bindings and the second is an expression which will be evaluated in an environment extended with those given bindings.</p>
<pre><code># (let ((a 10)) (+ a 1))
&gt; 11
</code></pre>
<p>If you want to set up more bindings with <code>let</code> it looks like this:</p>
<pre><code># (let ((a 10) (b 20) (c 30)) (+ a b c))
&gt; 60
</code></pre>
<p>It is also possible to nest <code>let</code> bindings and locally override a binding:</p>
<pre><code># (let ((a 1)) (+ a (let ((a 10)) (+ a a))))
&gt; 21
</code></pre>
<p>Below is an example that shows that a local binding also overrides a global binding and that the global binding is left unchanged when leaving the local scope.</p>
<pre><code># (let ((apa 1000)) (+ apa 1))
&gt; 1001
# apa
&gt; 1
</code></pre>
<p>The form of <code>let</code> used in lispBM allows an earlier binding in the list of bindings to be used as part of computations in later bindings.</p>
<pre><code># (let ((g 1) (h (+ g 1000))) h)
&gt; 1001

</code></pre>
<h3 id="lambda-and-closure"><code>lambda</code> and <code>closure</code></h3>
<p>New functions are defined using <code>lambda</code> that takes two arguments a list of parameter names and an expression. Using <code>lambda</code> creates an anonymous function that can be either directly applied or bound to a name using either <code>define</code> or <code>let</code>.</p>
<p>Here is an example of a directly applied anonymous function:</p>
<pre><code># ((lambda (x) (+ x x)) 2)
&gt; 4
</code></pre>
<p>That is a lot of parentheses and may be hard to read. Binding the anonymous function to a name may help a bit.</p>
<pre><code># (define f (lambda (x) (+ x x)))
&gt; t
# (f 2)
&gt; 4
# 
</code></pre>
<p>Evaluating the expression <code>(lambda (x) (+ x x))</code> results in a <code>closure</code>.</p>
<pre><code># (lambda (x) (+ x x))
&gt; (closure ((x nil) ((+ (x (x nil))) (nil nil))))
</code></pre>
<p>The <code>closure</code> looks very similar to the original <code>lambda</code> except that it has one more parameter, an environment. When forming a <code>closure</code> any local bindings that are needed within the expression body of the lambda is sucked into this closure-local environment. This is what makes it possible for us to write functions that return functions. Here is an example of a closure with sucked-in values from the surrounding local scope:</p>
<pre><code># (let ((y 100)) (lambda (x) (+ x y)))
&gt; (closure ((x nil) ((+ (x (y nil))) (((y 100) nil) nil))))

</code></pre>
<p>Here we can see that the binding <code>(y 100)</code> is present in the <code>closure</code> object created.</p>
<h3 id="progn"><code>progn</code></h3>
<p>The <code>progn</code> primitive evaluates a sequence (an arbitrary number of) expressions for side-effects and finally returns the value of the last expression in the sequence as the final result.</p>
<pre><code># (progn (print &quot;Hello world&quot; \#newline) (+ 1 2))
Hello world
&gt; 3
</code></pre>
<p>The <code>print</code> function used in this example is an <em>extension</em>. Extensions are a way to add platform dependent functionality to lispBM. The target platforms have many different ways of dealing with this kind of IO so I don't want to build any expectations on existing methods of presenting text into lispBM itself. There are still a few calls to <code>printf</code> present in lispBM but removing these are on the todo-list.</p>
<h3 id="a-slightly-larger-example">A Slightly Larger Example</h3>
<p>Here is a larger example that makes combined use of many of the features introduced above. It is a function that computes the nth Fibonacci number in a tail-recursive way. There will be more about tail-recursion in the section about the evaluator.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb22-1"><a href="#cb22-1"></a>(define fib (<span class="kw">lambda</span> (n)</span>
<span id="cb22-2"><a href="#cb22-2"></a>          (<span class="kw">let</span> ((fib0 (<span class="kw">lambda</span> (n a b)</span>
<span id="cb22-3"><a href="#cb22-3"></a>               (<span class="kw">if</span> (<span class="op">=</span> n <span class="dv">0</span>) a</span>
<span id="cb22-4"><a href="#cb22-4"></a>                 (<span class="kw">if</span> (<span class="op">=</span> n <span class="dv">1</span>) b</span>
<span id="cb22-5"><a href="#cb22-5"></a>                   (fib0 (<span class="op">-</span> n <span class="dv">1</span>) b (<span class="op">+</span> a b)))))))</span>
<span id="cb22-6"><a href="#cb22-6"></a>        (fib0 n <span class="dv">0</span> <span class="dv">1</span>))))</span>
<span id="cb22-7"><a href="#cb22-7"></a></span>
<span id="cb22-8"><a href="#cb22-8"></a></span>
<span id="cb22-9"><a href="#cb22-9"></a>(fib <span class="dv">10</span>)</span></code></pre></div>
<p>This example code evaluates to <code>55</code>.</p>
<p>With this example we conclude the walk through of some fundamental language constructs that can be used in lispBM programs. From now on this text will be mostly about how these things are implemented.</p>
<h2 id="heap-consisting-of-cons-cells">Heap Consisting of Cons cells</h2>
<p>The implementation of the heap is found in the files <code>heap.c</code> under <code>src</code> and <code>heap.h</code> under <code>include</code>. The <code>heap.h</code> file also contains quite a bit of commentary showing the choices I was contemplating there.</p>
<p>A type called <code>VALUE</code> is defined in <code>typedefs.h</code> and represents values that make sense in a lisp computation. <code>VALUE</code> is really just a 32Bit unsigned integer. I mention <code>VALUE</code> here as it is frequently used throughout. Another type that is quite frequently in use is <code>UINT</code> which is the same size as <code>VALUE</code> but does not necessarily make sense in the lisp world. <code>UINT</code> is used when it is important that the size matches that of a <code>VALUE</code>. Maybe because it will be turned into a <code>VALUE</code>. When it does not matter if a type matches in size with <code>VALUE</code>, I use <code>int</code> or <code>bool</code> or whatever is needed. This is the case when data that is used only internally in the runtime system. I am not very strict on conventions and will at some point try to take a pass over all code and make it a bit more aligned in that sense.</p>
<p>Within the lispBM runtime system a cons cell is represented by the struct:</p>
<pre><code>typedef struct {
  VALUE car;
  VALUE cdr;
} cons_t;
</code></pre>
<p>Where <code>VALUE</code> is defined as:</p>
<pre><code>typedef uint32_t VALUE;
</code></pre>
<p>As an example a heap of 1024 cons cells is allocated as follows</p>
<pre><code>cons_t *heap = (cons_t *)malloc(1024 * sizeof(cons_t));
</code></pre>
<p>The <code>VALUE</code> type is a 32bit word used to store: symbols (these are special values that represent variables, pieces of syntax and many other things), signed and unsigned integers and characters. The <code>VALUE</code> type is also large enough to hold a pointer within the heap used to set up linked data-structures. But there is also a lot of bookkeeping that needs to be tracked within the 32bit word (an alternative would be to use additional fields within the <code>cons_t</code> structure for this information. This would mean that the whole 32bit word is usable to store data, but it would increase the memory footprint of the heap.).</p>
<p>The information that is kept within the 32bits of a <code>VALUE</code> is:</p>
<ol>
<li>one mark-bit for the <em>Garbage Collector</em> (explained in a future blog post).</li>
<li>one bit that differentiates between pointers and values.</li>
<li>In the case of a value, an additional 2 further bits are used to encode the type of that value.</li>
<li>In the case of a pointer, there are several bits that are unused. This is because the heap is <em>small</em> (from kilobytes on the small MCUs up to 64MB on the Zynq) and to represent these <em>offsets</em> not that many bits are needed.</li>
</ol>
<p>The binary representation of a pointer stored in either the <code>car</code> or the <code>cdr</code> has the following shape:</p>
<pre><code>Bit pos: 31 30 29 28 27 26                               2 1 0
Bit val: 0  0  0  0  0  0  XX XXXX XXXX XXXX XXXX XXXX X 0 0 0
</code></pre>
<p>Since the value of the pointer, made up by the Xed out bits above, is only meant to reference other cons cells (which are 8 bytes apart in the allocated heap) the bottom three bits are unused. The zero in position 0 is used to differentiate between pointer and value, thus all pointers will have a zero there and all values will have a one. Bit position 1 is used for the Garbage Collector's mark-bit but only in the <code>car</code> position, in the <code>cdr</code> this bit is unused. Bit position 2 is unused. Depending on how large the heap is there is some number of bits unused on the most significant side as well. The example shows the bits used for a 64MB heap.</p>
<p>For a value there are 28 bits left. Bit 0 and 1 work exactly as in the case above for pointers. That is, bit 0 and 1 are used for differentiation with a pointer and garbage collection. Bits 2 and 3 are used to encode 4 different <em>types</em> of values.</p>
<p>The different types of values are:</p>
<ol>
<li>symbols.</li>
<li>28Bit integer.</li>
<li>28Bit unsigned integer.</li>
<li>Character.</li>
</ol>
<p>That was a lot of text about values for a section about the heap. But these two concepts are pretty tightly linked as all that extra runtime information bookkeeping has to go in there and be available to for example the garbage collector.</p>
<p>After allocating the heap, the next step is to link all the cons cells that it consists of into a single, long, linked list called the <code>free_list</code>.</p>
<p>When a program is requesting a fresh cons cell, for example from a usage of the <code>cons</code> function, the head (car) of the <code>free_list</code> is provided. The <code>free_list</code> variable is then set to the cdr of itself. This operation is performed by the function <code>heap_allocate_cell</code> in file <code>heap.c</code>. If there are no free cells on the <code>free_list</code> the heap allocation returns a symbol indicating out of heap. This will trigger the evaluator to perform a round of garbage collection.</p>
<p><img src="./media/heap_allocate_cell.png" title="Heap allocate cell" alt="Heap allocate cell" /></p>
<h2 id="symbols">Symbols</h2>
<p>Symbols are represented by text strings in source (or in what you enter into the REPL). So for example if the line <code>(define accumulator 0)</code> is entered into the REPL, <code>accumulator</code> is a symbol. The word <code>define</code> is actually also a symbol.</p>
<p>But as we have seen symbols can live on the heap. This means that the string of text that is the symbol in the source code must be turned into something that can be stored in a <code>VALUE</code>.</p>
<p>In lispBM the files <code>symrepr.h</code> and <code>symrepr.c</code> takes care of this conversion from text strings to integer values. It is also important that the backwards mapping from the integer value to the text string is maintained so that the string representation can be presented to the user of the REPL rather than just some obscure number. There are currently two different implementations maintaining this mapping of symbols as integers to symbols as string and the other way around. One implementation based on a hash-table and one based on a linked-list. The hash-table implementation has a larger memory footprint but should allow for faster lookups while the linked-list implementation uses memory proportional to the number of symbols that have been introduced. When using lispBM on, for example, an STM32 with less memory the linked-list implementation is used.</p>
<p>Symbols are stored on the heap and thus they must fit into a <code>VALUE</code>. This means there are only 28Bits available to represent different symbols since there are 4Bits that represent type and used by garbage collector and so on (28 bits should be plenty enough though!.).</p>
<p>Using the hash-table or the linked-list the conversion process is very similar.</p>
<p>The string representation of a symbol is hashed into a 16Bit value. Actually a value between <code>0</code> and <code>0xFFFE</code>. This means that there can be collisions where 2 different symbols have the same 16Bit id. Collisions are resolved by each bucket of the hash-table (or each element of the linked-list) contain a linked-list of length at most 4096. So if two values collide and have the same 16Bit id, they will get an additional 12Bits of id that depends upon how deeply within the (bucket) linked list they are.</p>
<pre><code>UINT hash_string(char *str, UINT modulo) {

  UINT r = 1;
  size_t n = strlen(str);

  for (UINT i = 0; i &lt; n; i ++) {
    UINT sp = small_primes[i % SMALL_PRIMES];
    UINT v = (UINT)str[i];
    r = (r + (sp * v)) % modulo;
  }

  return r;
}
</code></pre>
<p>The <code>hash_string</code> function is called with a <code>modulo</code> of <code>0xFFFF</code> which means that the return value can never be <code>0xFFFF</code>. This frees up 4096 symbols that it is impossible to <strong>create</strong> from a source string entered by the lispBM programmer. These 4096 symbols are treated specially in the implementation for things like signaling errors and for symbols that are present by default (such as <code>nil</code> and <code>define</code>).</p>
<h2 id="environments">Environments</h2>
<p>Environments store mappings between symbols and expressions. In lispBM environments are implemented as lists made from cons cells on the heap. The files <code>env.c</code> and <code>env.h</code> contains five functions used to manipulate environments.</p>
<pre><code>VALUE env_set(VALUE env, VALUE key, VALUE val);
VALUE env_lookup(VALUE sym, VALUE env);
VALUE env_copy_shallow(VALUE env);
VALUE env_modify_binding(VALUE env, VALUE key, VALUE val);
VALUE env_build_params_args(VALUE params, VALUE args, VALUE env0);
</code></pre>
<p>The function <code>env_set</code> adds a key-value pair to an environment. However, if the key-value binding already exists in the environment then this existing binding is updated instead.</p>
<p>Looking up in the environment is done using the <code>env_lookup</code> function. This function loops over the cons cells that make up the environment and if a key-value pair matches the key provided, the value part is returned. If no binding that matches is found, a special symbol called error_not_found is returned.</p>
<p>The <code>env_set</code> and the <code>env_lookup</code> functions are used by the evaluator to implement the function <code>define</code> and for looking up what variables are bound to as in <code>(+ a b)</code>. The rest of the functions, <code>env_copy_shallow</code>, <code>env_modify_binding</code> and <code>env_build_params_args</code> have more specific use cases related to <code>let</code> and <code>closure</code> and applications that will be pointed out in the section about evaluation.</p>
<h2 id="parsing">Parsing</h2>
<p>The Current parser used in lispBM is contained in files <code>tokpar.c</code> and <code>tokpar.h</code>. Earlier the MPC library (Parser combinators for C) was used but showed to be too memory hungry for my liking. And before finding MPC I looked briefly at more traditional parser generators such as <a href="https://bnfc.digitalgrammars.com/">BNFC</a>, <a href="https://github.com/westes/flex">Flex</a> and <a href="https://www.gnu.org/software/bison/">Bison</a>. But the C code generated from these setups seemed clunky and obscure. I did not really know how to port that code over to an embedded platform. Maybe parser generators specifically for embedded platforms should be a thing? These should generate code with an absolute minimal set of dependencies and they could even require the user of them to implement a small interfacing layer that provides the functionality needed in terms of the operations available in the HAL used. Such generated parser should also use as little memory as possible and maybe be ok with operating in a small (fixed size) memory area provided as an argument from the user.</p>
<p>The parser in lispBM operates on an abstracted character stream that provides four operations: <code>more</code>, <code>get</code>, <code>peek</code> and <code>drop</code>.</p>
<ol>
<li><code>more</code> checks if there are elements left in the character stream and returns a boolean.</li>
<li><code>get</code> returns the character at the head of the character stream and removes it from the stream.</li>
<li><code>peek</code> takes an integer offset and returns a character found at the point in the stream (counted from the head of the stream).</li>
<li><code>drop</code> removes N characters from the stream.</li>
</ol>
<p>The reason it is abstracted like this is that lispBM can read both plain strings of ASCII characters as well as a compressed stream of characters. In the case of reading a compressed stream this approach with an arbitrary <code>peek</code> will result in the stream being decoded multiple times (but only up peek-depth), trading compute resources for memory usage.</p>
<h2 id="printing">Printing</h2>
<p>The printing of expressions is an area that has not been given a lot of love or attention in lispBM. Printing functionality is contained in files <code>print.c</code> and <code>print.h</code> and provides the functions <code>simple_print</code> and <code>simple_snprint</code>. These functions recurse over a heap representation of an expression and can get stuck if the there is a circular structure on the heap, so they must be used carefully.</p>
<p>The <code>simple_snprint</code> prints into a buffer provided from the user and it does not grow that buffer. <code>simple_print</code>, however, uses <code>printf</code>. Here using the <code>snprint</code> variant is preferred, then let some HAL functionality take care of relaying the print buffer to the user maybe over UART. Having a the <code>printf</code> based version is of course convenient when working on X86 (32Bit) under linux for testing and debugging.</p>
<h2 id="evaluating-expressions">Evaluating Expressions</h2>
<p>The functions that are used in evaluating lispBM expressions is found in the file <code>eval_cps.c</code> with accompanying <code>eval_cps.h</code> file of course. The entry point function here is called <code>eval_cps_program</code>:</p>
<pre><code>VALUE eval_cps_program(VALUE lisp);
</code></pre>
<p>The argument <code>lisp</code> should be a list of lispBM expressions on the heap. These will be evaluated from the first to the last one. The result that the last expression evaluates to is returned to the caller of <code>eval_cps_program</code>.</p>
<p>The evaluator used in lispBM is an attempt at a continuation passing style evaluator. While implementing this I looked a lot at <a href="http://lisperator.net/pltut/cps-evaluator/">Lisperator</a> and it helped me quite a bit. However, writing this in C rather than, I think it was, Javascript introduces some extra complexities. One big difference is that it seems to be possible in javascript to create functions on the fly, which I guess is "impossible" in C (if you don't have some kind of a JIT compilation library in there as well). This is a feature that seems to be quite handy when creating a so-called continuation.</p>
<p>The following code snippet is borrowed from <a href="http://lisperator.net/pltut/cps-evaluator/">Lisperator</a>:</p>
<pre><code>function evaluate(exp, env, callback) {
    switch (exp.type) {

...

    case &quot;call&quot;:
        evaluate(exp.func, env, function(func){
            (function loop(args, i){
                if (i &lt; exp.args.length) evaluate(exp.args[i], env, function(arg){
                    args[i + 1] = arg;
                    loop(args, i + 1);
                }); else {
                    func.apply(null, args);
                }
            })([ callback ], 0);
        });
        return;

...
    }
}
</code></pre>
<p>The code above shows how function application can be evaluated in continuation passing style in a more expressive language than C.</p>
<p>The "call" case above is used to evaluate something like <code>(f a b c)</code> where <code>f</code> is an expression that evaluates to a function (for example a <code>lambda</code> in lispBM). <code>a</code>, <code>b</code> and <code>c</code> are the expressions passed as argument. The application could as an example look like this: <code>(f (+ 1 2) (- 3 2) 1)</code>.</p>
<p>So, within the "call" case above, the evaluate function is called with <code>f</code> and an environment as arguments. It is also passed a function that is created on the spot (the continuation), <code>function(func){ ... }</code>.</p>
<p>The continuation function represents what to do next (that is, after evaluating the function itself in this case). The continuation specified here iterates over the arguments arguments to <code>f</code> and evaluates them one after other and puts the results in a list. Once all arguments are evaluated, the function can be applied to them; It is already evaluated into some applicable func object at this point. For more in depth information on this go to <a href="http://lisperator.net/pltut/cps-evaluator/">Lisperator</a>.</p>
<p>Now, In C it is not (easily) possible to do generate a continuation function in this way. But fortunately it is not necessary to be able to create totally arbitrary functions (at least this is what it seems like to me), just a few different kinds of continuations has to be implemented. Maybe it is possible to think of the approach used in lispBM as a kind of defunctionalized continuation passing style?</p>
<p>The implementation of evaluation in lispBM relies on a stack holding 32Bit words (same size as <code>values</code>) that represents the continuation together with a set of 9 predefined continuation functions that are identified by the following definitions:</p>
<pre><code>#define DONE              1
#define SET_GLOBAL_ENV    2
#define FUNCTION_APP      3
#define FUNCTION          4
#define BIND_TO_KEY_REST  5
#define IF                6
#define ARG_LIST          7
#define EVAL              8
#define PROGN_REST        9
</code></pre>
<p>I'm going to try to illustrate how this works by showing a few cases from the evaluator in lispBM. But first a few concepts must be introduced for it to make sense.</p>
<p>While the function <code>cps_eval_program</code> is what the REPL calls, the function that does the actual evaluation is called <code>run_eval</code>.</p>
<pre><code>VALUE run_eval(eval_context_t *ctx);
</code></pre>
<p>The <code>run_eval</code> function takes a <code>eval_context_t</code> as argument. There is a global such context that is initiated by the <code>cps_eval_program</code> function before it in turn calls <code>run_eval</code>. The eval context contains and keeps track of environment, current evaluation point and the continuation stack.</p>
<pre><code>typedef struct eval_context_s{
  VALUE program;
  VALUE curr_exp;
  VALUE curr_env;
  stack *K;
  struct eval_context_s *next;
} eval_context_t;

</code></pre>
<p>The very first thing that <code>run_eval</code> does is push a continuation onto the continuation stack:</p>
<pre><code>VALUE run_eval(eval_context_t *ctx){

  push_u32(ctx-&gt;K, enc_u(DONE));
</code></pre>
<p>The <code>DONE</code> continuation will now be present as the only element on the stack. This continuation represents that computation of the program is finished.</p>
<p>Next a <code>run_eval</code> enters into a loop:</p>
<pre><code>  VALUE r = NIL;
  bool done = false;
  bool app_cont = false;

  while (!done) {

    if (app_cont) {
       r = apply_continuation(ctx, r, &amp;done, &amp;app_cont);
       continue;
     }
    ...

</code></pre>
<p>Some things related to garbage collection are omitted from <code>run_eval</code> at this point. I hope to soon write a text about the garbage collection and will then revisit the evaluater there.</p>
<p>The <code>r</code> variable defined above represents the result of the computation and is what will be returned from <code>run_eval</code> in the end.</p>
<p>What is essential here is that within the loop there is a <code>switch</code> statement that branches depending on what kind of expression is in the variable <code>curr_exp</code> within the context.</p>
<pre><code>    VALUE value;  // a temporary value used throughout.
    switch (type_of(ctx-&gt;curr_exp)) {
    case VAL_TYPE_I:
      app_cont = true;
      r = ctx-&gt;curr_exp;
      break;
</code></pre>
<p>If the expression is an integer it is an easy case. The <code>app_cont</code> variable is set to true which means that in the next iteration of the while loop the continuation will be applied.</p>
<p>Another not to tricky case is when <code>curr_exp</code> is a variable.</p>
<pre><code>    case VAL_TYPE_SYMBOL:
      value = env_lookup(ctx-&gt;curr_exp, ctx-&gt;curr_env);
      if (type_of(value) == VAL_TYPE_SYMBOL &amp;&amp;
      dec_sym(value) == symrepr_not_found()) {
        r = enc_sym(symrepr_eerror());
        done = true;
        continue;
      } 
      app_cont = true;
      r = value;
      break;
</code></pre>
<p>In the <code>VAL_TYPE_SYMBOL</code> case the <code>curr_exp</code> represents a symbol and is looked up in the environment. If the symbol is not found the result of the computation is set to an error symbol signaling evaluation error and the <code>done</code> flag is set to <code>true</code>. If the symbol has a binding, <code>r</code> is set to this binding and the next step will apply the continuation.</p>
<p>The <code>VAL_TYPE_SYMBOL</code> case is slightly simplified as shown above. In the actual implementation it also looks up the symbol in the global environment and only if it is not present in either there will be an error. There is also a check if the symbol corresponds to some built in function or some extension. But this is left out from here.</p>
<p>If the <code>curr_exp</code> is a list we end up in the following case:</p>
<pre><code>    case PTR_TYPE_CONS:
      head = car(ctx-&gt;curr_exp);
      if (type_of(head) == VAL_TYPE_SYMBOL) {
</code></pre>
<p>In the case of a list the evaluator can take many different paths depending on what the first element of that list is. For example, if the first element is the symbol <code>define</code>, the list of expressions represents defining a binding in the global environment. If the first element of the list is `lambda', the list represents a function definition and so on for all the <em>special forms</em>.</p>
<p>Let's look at a few of the possible cases within the <code>PTR_TYPE_CONS</code> case, starting with the <code>'</code> <em>quote</em> case.</p>
<pre><code>    if (dec_sym(head) == symrepr_quote()) {
      r = car(cdr(ctx-&gt;curr_exp));
      app_cont = true;
      continue;
    }
</code></pre>
<p>This case is also one of the simpler ones. <code>r</code> is set to the rest of the list and we apply the continuation.</p>
<p>Now it is time for a more interesting case, <code>define</code>.</p>
<pre><code>    if (dec_sym(head) == symrepr_define()) {
      VALUE key = car(cdr(ctx-&gt;curr_exp));
      VALUE val_exp = car(cdr(cdr(ctx-&gt;curr_exp)));

      if (type_of(key) != VAL_TYPE_SYMBOL ||
          key == NIL) {
        done = true;
        r =  enc_sym(symrepr_eerror());
        continue;
      }

      push_u32_2(ctx-&gt;K, key, enc_u(SET_GLOBAL_ENV));
      ctx-&gt;curr_exp = val_exp;
      continue;
    }
</code></pre>
<p>The <code>define</code> form takes two arguments the key and an expression. In lispBM when using <code>define</code> the value expression is evaluated before the key-val binding is created. So the key is bound to the evaluated result of the value expression. There is a small bit of error checking here in case someone tries to rebind <code>nil</code>.</p>
<p>The interesting part is the last three lines. Here the key and the continuation identifier for <code>SET_GLOBAL_ENV</code> are both pushed onto the continuation stack. The <code>curr_exp</code> of the context is set to the value expression and the eval loop starts over. This means that the next thing that will happen is that the value expression is evaluated and once that reduces to a basic case the continuation <code>SET_GLOBAL_ENV</code> will be applied.</p>
<p>One more example to close the circle with the initial example that I got from Lisperator. The function application case.</p>
<p>In the evaluator the function application case is what is used if no other special form (<code>define</code>, <code>lambda</code>, `if', ...) was applicable.</p>
<pre><code>      push_u32_2(ctx-&gt;K, head, enc_u(FUNCTION));
      if (type_of(cdr(ctx-&gt;curr_exp)) == VAL_TYPE_SYMBOL &amp;&amp;
      cdr(ctx-&gt;curr_exp) == NIL) {
        // no arguments
        app_cont = true;
        r = NIL;
        continue;
      } else {
        push_u32_4(ctx-&gt;K, ctx-&gt;curr_env, NIL,
                   cdr(cdr(ctx-&gt;curr_exp)), enc_u(ARG_LIST));

        ctx-&gt;curr_exp = car(cdr(ctx-&gt;curr_exp));
        continue;
      }
</code></pre>
<p>This starts out by pushing the head of the list (that represents the function) and a value representing the <code>FUNCTION</code> continuation onto the stack. Then either there are no arguments to the function or there are. If there are none we set <code>app_cont</code> and let the continuation proceed. Which will go directly into the <code>FUNCTION</code> continuation and compute it. If there are arguments four things are pushed onto the continuation stack:</p>
<ol>
<li>The current environment (that all of these arguments should be evaluated in)</li>
<li>An empty accumulator list.</li>
<li>The tail of the list of arguments.</li>
<li>The <code>ARG_LIST</code> continuation.</li>
</ol>
<p>Then the <code>curr_exp</code> in the context is set to the first element of the argument list and the evaluator loops restarts from the beginning.</p>
<p>So, if the <code>app_cont</code> flag is set when we enter a new iteration of the loop we jump to an <code>apply_continuation</code> function.</p>
<pre><code>VALUE apply_continuation(eval_context_t *ctx, VALUE arg, bool *done, bool *app_cont) {
</code></pre>
<p>This function is a huge switch statement that depends on what the top value of the continuation stack is. The first couple of lines look like this. Here the top of the stack is popped, some variables defined, <code>app_cont</code> set to a default <code>false</code> state.</p>
<pre><code>  VALUE k;
  pop_u32(ctx-&gt;K, &amp;k);

  VALUE res;

  *app_cont = false;

  switch(dec_u(k)) {
  case DONE:
    *done = true;
    return arg;
</code></pre>
<p>The line above also shows what happen in the case of the <code>DONE</code> continuation. This case sets <code>done</code> to <code>true</code> in order to break the eval loop and returns the argument passed to the continuation as a result.</p>
<p>Let's revisit those cases from the evaluator that pushed continuations. Starting with <code>define</code> that pushed the <code>SET_GLOBAL_ENV</code> continuation.</p>
<pre><code> case SET_GLOBAL_ENV:
    res = cont_set_global_env(ctx, arg, done, perform_gc);
    if (!(*done)) 
      *app_cont = true;
    return res;
</code></pre>
<p>It relies on a helper function that updates the actual environment <code>cont_set_global</code>. If this was to fail (fatally) <code>done</code> would be set to true and res will be an error indicating symbol. If it is successful <code>app_cont</code> is set to true and the result (which should be <code>t</code>) is returned.</p>
<pre><code> case FUNCTION: {
    VALUE fun;
    pop_u32(ctx-&gt;K, &amp;fun);
    push_u32_2(ctx-&gt;K, arg, enc_u(FUNCTION_APP));
    
    ctx-&gt;curr_exp = fun;
    return NONSENSE; // Should return something that is very easy to recognize as nonsense 
  }
</code></pre>
<p>The <code>FUNCTION</code> continuation pops off the function expression from the stack and then pushes <code>arg</code> that represents the argument list and the <code>FUNCTION_APP</code> continuation to the stack.</p>
<p>Then the context is set up so that the function expression is evaluated into a function object (<code>closure</code>, extension, built in function).</p>
<pre><code> case ARG_LIST: {
    VALUE rest;
    VALUE acc;
    VALUE env;
    pop_u32_3(ctx-&gt;K, &amp;rest, &amp;acc, &amp;env);
    VALUE acc_ = cons(arg, acc);
    if (type_of(rest) == VAL_TYPE_SYMBOL &amp;&amp;
        rest == NIL) {
      *app_cont = true;
      return acc_;
    }
    VALUE head = car(rest);
    push_u32_4(ctx-&gt;K, env, acc_, cdr(rest), enc_u(ARG_LIST));
    ctx-&gt;curr_env = env;
    ctx-&gt;curr_exp = head;
    return NONSENSE;
  }
</code></pre>
<p>The <code>ARG_LIST</code> continuation pops of the environment, accumulator and "rest of the list of arguments" from the stack. It conses the arg (which is the first evaluated argument) to the accumulator and then checks if the "rest of the list of arguments" is empty. In that case we are done and can apply the continuation. If it is not empty a second round of <code>ARG_LIST</code> continuation is initiated in the same way as it was first done in the evaluation function.</p>
<p>So, The point of implementing the evaluator in this convoluted way using continuation passing style. As I understand it (and what experiments seems to show) is that with this evaluator It is possible to evaluate tail-recursive functions such that it does not result in memory usage that grows with each recursive call. One thing I want to be able to run on the microcontrollers are infinite loops. In lispBM I would express such a function as a tail-recursion and it should be possible to run it indefinitely. I think another option would be to transform the program itself (the program to evaluate) into what is called continuation passing style. Then an evaluator for that continuation passing style program could be written in a way that has the same property. I think there are some cases in the evaluator where one has to be very careful with in what order things are done not to fall into the growing stack problem. Also, I have no strong argument that this evaluator is currently totally correct. It does seem to run quite well though!</p>
<p>I hope this gives a taste of how the CPS evaluator works. If you have insights or questions please contact me.</p>
<h2 id="a-prelude-of-convenient-lisp-functions">A Prelude of Convenient Lisp Functions</h2>
<p>The following set of lispBM functions are included into the binary generated when compiling lispBM and are added to the global environment on startup.</p>
<p>This functionality can be turned on or off at compile-time depending on if <code>_PRELUDE</code> is defined or not.</p>
<pre><code>(define reverse
  (lambda (xs)
    (let ((revacc (lambda (acc xs)
            (if (= nil xs)
            acc
              (revacc (cons (car xs) acc) (cdr xs))))))
      (revacc nil xs))))


(define iota (lambda (n)
           (let ((iacc (lambda (acc i n)
                 (if (&gt; i n)
                 acc
                   (iacc (cons (- n i) acc) (+ i 1) n)))))
         (iacc nil 0 n))))

(define length (lambda (xs)
         (let ((len (lambda (l xs)
                  (if (= xs nil)
                  l
                (len (+ l 1) (cdr xs))))))
           (len 0 xs))))

(define take (lambda (n xs)
           (if (num-eq n 0)
           nil
         (cons (car xs)
               (take (- n 1) (cdr xs))))))

(define drop (lambda (n xs)
           (if (num-eq n 0)
           xs
         (if (= xs nil)
             nil
           (drop (- n 1) (cdr xs))))))

(define zip (lambda (xs ys)
          (if ( = xs nil)
          nil
        (if ( = ys nil)
            nil
          (cons (cons (car xs) (car ys)) (zip (cdr xs) (cdr ys)))))))

(define map (lambda (f xs)
          (if (= xs nil)
          nil
        (cons (f (car xs)) (map f (cdr xs))))))

(define lookup (lambda (x xs)
         (if (= xs nil)
             nil
           (if (= (car (car xs)) x)
               (cdr (car xs))
             (lookup x (cdr xs))))))

(define foldr (lambda (f i xs)
        (if (= xs nil)
            i
          (f (car xs) (foldr f i (cdr xs))))))

(define foldl (lambda (f i xs)
        (if (= xs nil)
            i
          (foldl f (f i (car xs)) (cdr xs)))))

</code></pre>
<p>EDIT: Here is a simpler variant of the <code>iota</code> function provided by <a href="http://www.cse.chalmers.se/~josefs/">Josef Svenningsson</a>.</p>
<pre><code>(define iota (lambda (n)
         (let ((iacc (lambda (acc i)
                 (if (&lt; i 0)
                 acc
                   (iacc (cons i acc) (- i 1))))))
         (iacc nil n))))
</code></pre>
<h2 id="things-left-out">Things Left Out</h2>
<ol>
<li>Garbage Collector.</li>
<li>Compression of source code.</li>
<li>Interfacing with ChibiOS.</li>
<li>Interfacing with ZephyrOS.</li>
<li>Build for a bare-metal Zynq 7010 (using Xilinx HAL).</li>
<li>Built in functions (<code>fundamental.c</code> and <code>fundamental.h</code>).</li>
<li>Extensions (<code>extensions.c</code> and <code>extensions.h</code>).</li>
</ol>
<p>I hope to write about these aspects of lispBM at a later time.</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<!-- horizontal unit -->

<p><ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-6663189426712847"
data-ad-slot="2225439322"
data-ad-format="auto"
data-full-width-responsive="true"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<hr />
<p><a href="https://svenssonjoel.github.io">HOME</a></p>
<p>© Copyright 2020 Bo Joel Svensson</p>
<p>This page was generated using <a href=https://pandoc.org/> Pandoc</a>.</p>
</BODY>
</HTML>
