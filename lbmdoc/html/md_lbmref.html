<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LispBM: LispBM language reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LispBM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">LispBM language reference </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>About Symbols</h1>
<p>Symbols are very important and fundamental to LispBM and also perhaps a bit different from identifiers/names used in languages such as C, so a short intro could be good here.</p>
<p>A symbol can be thought of as a name and can be used to give names to functions or values (variables). A symbol can also be treated and used as a value in and of itself a value (or data). So it can be used to name data and functions and is itself also data.</p>
<hr  />
<p><b>NOTE</b></p>
<p>Symbols are expressed as strings in your program such as <code>a</code>, <code>let</code>, <code>define</code>, <code>+</code> or <code>orange</code>. The "reader", the part of LBM that parses code, translates each symbol into a 28bit value. The string <code>orange</code> for example is only of interest if you print a symbol and then the runtime system will look up what string corresponds to the 28bit identifier you want to print. So the runtime system is never wasting time comparing strings to see if a symbol is this or that symbol, it's all integer comparisons.</p>
<hr  />
<p>You associate values with symbols using, <a href="#define">define</a>, <a href="#let">let</a> and you can change the value bound to a "variable" using <a href="#setvar">setvar</a></p>
<p>Not all symbols are treated the same in LBM. Some symbols are treated as special because of their very fundamental nature. Among these special symbols you find <code>define</code>, <code>let</code> and <code>lambda</code> for example. These are things that you should not be able to redefine and trying to redefine them leads to an error. There are two classes of symbols that are special by naming convention and these either start with a <code>#</code>, for fast-lookup variables, and <code>ext-</code> for extensions that will be bound at runtime.</p>
<p>Examples of symbols used as data are <code>nil</code> and <code>t</code>. <code>nil</code> is used the represent nothing, the empty list or other similar things and <code>t</code> represents true. But any symbol can be used as data by quoting it &lsquo;&rsquo;`, see <a href="#quotes-and-quasiquotation">Quotes and Quasiquotation </a>.</p>
<h1>Arithmetic</h1>
<h2>+</h2>
<p>Adds up an aribtrary number of values. The form of a <code>+</code> expression is <code>(+ expr1 ... exprN)</code></p>
<p>Example adding up two numbers. The result is 3. </p><div class="fragment"><div class="line">(+ 1 2)</div>
</div><!-- fragment --><p> When adding up values of different types values are converted. </p><div class="fragment"><div class="line">(+ 1i 3.14)</div>
</div><!-- fragment --><p> The example above evaluates to float value 4.14.<br  />
 You can add up multiple values. </p><div class="fragment"><div class="line">(+ 1 2 3 4 5 6 7 8 9 10)</div>
</div><!-- fragment --><p> The example above results in the value 55.</p>
<hr  />
<h2>-</h2>
<p>Subtract an arbitrary number of values from a value. The form of a - expression is <code>(- expr1 ... exprN)</code></p>
<p>Example subtracting 3 from 5. </p><div class="fragment"><div class="line">(- 5 3)</div>
</div><!-- fragment --><hr  />
<h2>*</h2>
<p>Multiplying an arbitrary number of values. The form of a * expression is <code>(* expr1 ... exprN)</code></p>
<p>Example 2pi. </p><div class="fragment"><div class="line">(* 2 3.14)</div>
</div><!-- fragment --><hr  />
<h2>/</h2>
<p>Division. The form of a / expression is <code>(/ expr1 ... exprN)</code>.</p>
<p>Divide 128 by 2 </p><div class="fragment"><div class="line">(/ 128 2)</div>
</div><!-- fragment --><p> The following example evaluates to 1. </p><div class="fragment"><div class="line">(/ 128 2 2 2 2 2 2 2)</div>
</div><!-- fragment --><hr  />
<h2>mod</h2>
<p>Modulo operation. The form of a mod expression is <code>(mod expr1 ... exprN)</code>.</p>
<p>Compute 5 % 3, evaluates to 2. </p><div class="fragment"><div class="line">(mod 5 3)</div>
</div><!-- fragment --><hr  />
<h1>Comparisons</h1>
<h2>eq</h2>
<p>Compare expressions for equality. The <code>eq</code> operation implements structural equality. The form of an <code>eq</code> expression is <code>(eq expr1 ... exprN)</code></p>
<p>Compare the result of <code>(+ 1 2)</code> with 3. The result of this comparison is <code>t</code>. </p><div class="fragment"><div class="line">(eq (+ 1 2) 3)</div>
</div><!-- fragment --><p> Multiple expressions can be checked at once. The examples below evaluates to <code>t</code> </p><div class="fragment"><div class="line">(eq 1 1 1 1)</div>
<div class="line"> </div>
<div class="line">(eq (+ 3 4) (+ 2 5) (+ 1 6))</div>
</div><!-- fragment --><p> The following examples evaluate to <code>nil</code> representing false. </p><div class="fragment"><div class="line">(eq 1 1 1 1 2)</div>
<div class="line"> </div>
<div class="line">(eq (+ 1 2) (+ 0 2) (+ -1 2))</div>
</div><!-- fragment --><p>The <code>eq</code> comparison can be used on tree shaped data. The following expression evaluates to <code>t</code>.</p>
<div class="fragment"><div class="line">(eq &#39;(1 (1 2)) &#39;(1 (1 2)))</div>
</div><!-- fragment --><hr  />
<h2>not-eq</h2>
<p><code>not-eq</code> implements the negation of eq. In other words, <code>(not-eq a b c)</code> evaluates to the same result as <code>(not (eq a b c))</code>.</p>
<hr  />
<h2>=</h2>
<p>The <code>=</code> operation can only be used on numerical arguments. If you know you are comparing numbers, it will be more efficient to use <code>=</code>.</p>
<p>An important difference between <code>eq</code> and <code>=</code> is that <code>=</code> compare the numerical values of the arguments. A 3 is a 3 independent of them being different types. <code>eq</code> on the other hand compares the representations of the arguments exactly and they must match in structure, type and value to be considered equal.</p>
<p>Example of <code>=</code> comparison. </p><div class="fragment"><div class="line">(= (+ 2 3) (+ 1 4))</div>
</div><!-- fragment --><hr  />
<h2>!=</h2>
<p>The <code>!=</code> operation implements the negation of <code>=</code>. So, <code>(!= a b)</code> evaluates to the same result as <code>(not (= a b))</code>.</p>
<hr  />
<h2>&gt;</h2>
<p>Greater than comparison. A greater than comparison has the form <code>(&gt; expr1 ... exprN)</code> and evaluates to <code>t</code> if expr1 is greater than all of expr2 ... exprN.</p>
<p>Example </p><div class="fragment"><div class="line">(&gt; 5 2)</div>
</div><!-- fragment --><hr  />
<h2>&lt;</h2>
<p>Less than comparison. A less than comparison has the form <code>(&gt; expr1 ... exprN)</code> and evaluates to <code>t</code> if expr1 is less than all of expr2 ... exprN.</p>
<p>Example </p><div class="fragment"><div class="line">(&lt; 5 2)</div>
</div><!-- fragment --><hr  />
<h2>&gt;=</h2>
<p>Greater than or equal comparison. A greater than comparison has the form <code>(&gt;= expr1 ... exprN)</code> and evaluates to <code>t</code> if expr1 is greater than or equal to all of expr2 ... exprN.</p>
<p>Example </p><div class="fragment"><div class="line">(&gt;= 5 2)</div>
</div><!-- fragment --><hr  />
<h2>&lt;=</h2>
<p>Less than or equal comparison. A less than or equal comparison has the form <code>(&lt;= expr1 ... exprN)</code> and evaluates to <code>t</code> if expr1 is less than or equal to all of expr2 ... exprN.</p>
<p>Example </p><div class="fragment"><div class="line">(&lt;= 5 2)</div>
</div><!-- fragment --><hr  />
<h1>Boolean operators</h1>
<h2>and</h2>
<p>Boolean <code>and</code> operation between n arguments. The form of an <code>and</code> expression is <code>(and expr1 ... exprN)</code>. This operation treats all non-nil values as true. Boolean <code>and</code> is "shirt-circuiting" and only evaluates until a false is encountered.</p>
<p>The example below evaluates to <code>t</code> </p><div class="fragment"><div class="line">(and t t)</div>
</div><!-- fragment --><p> The following example evaluates to 3 </p><div class="fragment"><div class="line">(and t t (+ 1 2))</div>
</div><!-- fragment --><p> And lastly an example that evaluates to nil (for false). </p><div class="fragment"><div class="line">(and t (&lt; 5 3))</div>
</div><!-- fragment --><hr  />
<h2>or</h2>
<p>Boolean <code>or</code> operation between n arguments. The form of an <code>or</code> expression is <code>(or expr1 ... exprN)</code>. This operation treats all non-nil values as true. Boolean <code>or</code> is "short-circuiting" and only evaluates until a true is encountered.</p>
<p>The example below evaluates to <code>t</code>. </p><div class="fragment"><div class="line">(or t nil)</div>
</div><!-- fragment --><hr  />
<h2>not</h2>
<p>Boolean <code>not</code> takes one argument. The form of a <code>not</code> expression is <code>(not expr)</code>. All non-nil values are considered true.</p>
<p>The following example evaluates to <code>t</code> </p><div class="fragment"><div class="line">(not nil)</div>
</div><!-- fragment --><hr  />
<h1>Bit level operations</h1>
<h2>shl</h2>
<p>The shift left operation takes two arguments. The first argument is a value to shift and the second argument is the number of bit positions to shift the value.</p>
<p>The example below evaluates to 4. </p><div class="fragment"><div class="line">(shl 1 2)</div>
</div><!-- fragment --><hr  />
<h2>shr</h2>
<p>The shift right operation takes two arguments. The first argument is a value to shift and the second argument in the number of bit positions to shift the value.</p>
<p>The example below evaluates to 1. </p><div class="fragment"><div class="line">(shr 4 2)</div>
</div><!-- fragment --><hr  />
<h2>bitwise-and</h2>
<p>Performs the bitwise and operation between two values. The type of the result is the same type as the first of the arguments.</p>
<hr  />
<h2>bitwise-or</h2>
<p>Performs the bitwise or operation between two values. The type of the result is the same type as the first of the arguments.</p>
<hr  />
<h2>bitwise-xor</h2>
<p>Performs the bitwise xor operation between two values. The type of the result is the same type as the first of the arguments.</p>
<hr  />
<h2>bitwise-not</h2>
<p>Performs the bitwise not operations on a value. The result is of same type as the argument.</p>
<hr  />
<h1>nil and t, true and false</h1>
<h2>nil</h2>
<p>Represents the empty list. The nil value is also considered to be false by conditionals</p>
<p>The example below creates a one element list by allocating a cons cell and putting a value (1) in the <a href="#car">car </a> field and nil in the <a href="#cdr">cdr </a> field. </p><div class="fragment"><div class="line">(cons 1 nil)</div>
</div><!-- fragment --><hr  />
<h2>t</h2>
<p>All non nil values are considered true in conditionals. <code>t</code> should be used in cases where an explicit true makes sense.</p>
<hr  />
<h2>true</h2>
<p><code>true</code> is an alias for <code>t</code>.</p>
<hr  />
<h2>false</h2>
<p><code>false</code> is an alias for <code>nil</code>.</p>
<hr  />
<h1>Quotes and Quasiquotation</h1>
<p>Code and data share the same representation, it is only a matter of how you look at it. The tools for changing how your view are the quotation and quasiquotation operations.</p>
<hr  />
<h2>quote</h2>
<p>Usages of the &lsquo;&rsquo;` quote symbol in input code is replaced with the symbol quote by the reader. Evaluating a quoted expression, (quote a), results in a unevaluated.</p>
<p>The program string &lsquo;&rsquo;(+ 1 2) <code>gets read into the heap as the list</code>(quote (+ 1 2))<code>. Evaluating the expression</code>(quote (+ 1 2))<code>results in the value</code>(+ 1 2)`.</p>
<hr  />
<h2>`</h2>
<p>The backwards tick <code>`</code> is called the quasiquote. It is similar to the &lsquo;&rsquo;` but allows splicing in results of computations using the <a href="#,">,</a> and the <a href="#commaat">,@</a> operators.</p>
<p>The result of &lsquo;&rsquo;(+ 1 2)<code>and</code>(+ 1 2)`<code>are similar in effect. Both result in the result value of</code>(+ 1 2)<code>, that is a list containing +, 1 and 2. When</code>(+ 1 2)`<code>is read into the heap it is expanded into the expression</code>(append (quote (+)) (append (quote (1)) (append (quote (2)) (quote nil))))<code>which evaluates to the list</code>(+ 1 2)`.</p>
<hr  />
<h2>,</h2>
<p>The comma is used to splice the result of a computation into a quasiquotation.</p>
<p>The expression <code>`(+ 1 ,(+ 1 1))</code> is expanded by the reader into <code>(append (quote (+)) (append (quote (1)) (append (list (+ 1 1)) (quote nil))))</code>. Evaluating the expression above results in the list <code>(+ 1 2)</code>.</p>
<hr  />
<h2>,&lt;/h2&gt; The comma-at operation is used to splice in the result of a computation (that returns a list) into a list. Example: @code{clj} (define mylist (list 1 2 3 4 5) `(9 6 5 ,@mylist) @endcode Evaluates to the list <code>(9 6 5 1 2 3 4 5)</code>. Built-in operations</h2>
<h2>eval</h2>
<p>Evaluate data as an expression. The data must represent a valid expression.</p>
<p>Example that evaluates to 3. </p><div class="fragment"><div class="line">(eval (list + 1 2))</div>
</div><!-- fragment --><hr  />
<h2>eval-program</h2>
<p>Evaluate a list of data where each element represents an expression.</p>
<p>Example that results in the value 15: </p><div class="fragment"><div class="line">(define prg &#39;( (+ 1 2) (+ 3 4) (+ 10 5)))</div>
<div class="line">(eval-program prg)</div>
</div><!-- fragment --><p>Example that prints the strings "apa", "bepa" and "cepa": </p><div class="fragment"><div class="line">(define prg &#39;( (print &quot;apa&quot;) (print &quot;bepa&quot;) (print &quot;cepa&quot;)))</div>
<div class="line">(eval-program prg)</div>
</div><!-- fragment --><hr  />
<h2>type-of</h2>
<p>The <code>type-of</code> function returns a symbol that indicates what type the argument is. The form of a <code>type-of</code> expression is <code>(type-of expr)</code>.</p>
<p>Example that evaluates to <code>type-float</code>. </p><div class="fragment"><div class="line">(type-of 3.14)</div>
</div><!-- fragment --><hr  />
<h2>sym2str</h2>
<p>The <code>sym2str</code> function converts a symbol to its string representation. The resulting string is a copy of the original so you cannot destroy built in symbols using this function.</p>
<p>Example that returns the string <code>"lambda"</code>. </p><div class="fragment"><div class="line">(sym2str &#39;lambda)</div>
</div><!-- fragment --><hr  />
<h2>str2sym</h2>
<p>The <code>str2sym</code> function converts a string to a symbol.</p>
<p>Example that returns the symbol <code>hello</code>. </p><div class="fragment"><div class="line">(str2sym &quot;hello&quot;)</div>
</div><!-- fragment --><hr  />
<h2>sym2u</h2>
<p>The <code>sym2u</code> function returns the numerical value used by the runtime system for a symbol.</p>
<p>Example that evaluates to 4. </p><div class="fragment"><div class="line">(sym2u &#39;lambda)</div>
</div><!-- fragment --><hr  />
<h2>u2sym</h2>
<p>The <code>u2sym</code> function returns the symbol associated with the numerical value provided. This symbol may be undefined in which case you get as result a unnamed symbol.</p>
<hr  />
<h1>Special forms</h1>
<h2>if</h2>
<p>Conditionals are written as <code>(if cond-expr then-expr else-expr)</code>. If the cond-expr evaluates to <a href="#nil">nil </a> the else-expr will be evaluated. for any other value of cond-expr the then-expr will be evaluated.</p>
<p>The example below evaluates to 0 if a is less than or equal to 4. Otherwise it evaluates to a + 10. </p><div class="fragment"><div class="line">(if (&gt; a 4) (+ a 10) 0)</div>
</div><!-- fragment --><hr  />
<h2>cond</h2>
<p><code>cond</code> is a generalization of <code>if</code> to discern between n different cases based on boolean expressions. The form of a <code>cond</code> expression is: <code>(cond ( cond-expr1 expr1) (cond-expr2 expr2) ... (cond-exprN exprN))</code>. The conditions are checked from first to last and for the first <code>cond-exprN</code> that evaluates to true, the corresponding <code>exprN</code> is evaluated.</p>
<p>If no <code>cond-exprN</code> evaluates to true, the result of the entire conditional is <code>nil</code>.</p>
<p>Example that prints "Hello world": </p><div class="fragment"><div class="line">(define a 0)</div>
<div class="line"> </div>
<div class="line">(cond ( (&lt; a 0) (print &quot;abrakadabra&quot;))</div>
<div class="line">      ( (&gt; a 0) (print &quot;llama&quot;))</div>
<div class="line">      ( (= a 0) (print &quot;Hello world&quot;)))</div>
</div><!-- fragment --><p>Example that evaluates to <code>nil</code> as none of the conditions evaluate to true. </p><h1>@code{clj} (define a 5) (cond ( (= a 1) 'doughnut ) ( (= a 7) 'apple-strudel ) ( (= a 10) 'baklava)) @endcode </h1>
<h2>lambda</h2>
<p>You create an anonymous function with lambda. The function can be given a name by binding the lambda expression using <a href="#define">define</a> or <a href="#let">let</a>. A lambda expression has the form <code>(lambda param-list body-expr)</code>.</p>
<p>The example shows an anonymous function that adds one. </p><div class="fragment"><div class="line">(lambda (x) (+ x 1))</div>
</div><!-- fragment --><p> A lambda can be immediately applied to an argument. </p><div class="fragment"><div class="line">((lambda (x) (+ x 1)) 10)</div>
</div><!-- fragment --><p> The application above results in the value 11. Using <a href="#define">define </a> you can give a name to the function. </p><div class="fragment"><div class="line">(define inc (lambda (x) (+ x 1)))</div>
</div><!-- fragment --><p> Now the expression <code>(inc 10)</code> computes the result 11.</p>
<hr  />
<h2>closure</h2>
<p>A <a href="#lambda">lambda </a> expression evaluates into a closure which is very similar to a <a href="#lambda">lambda</a> but extended with a captured environment for any names unbound in the param-list appearing in the body-expr. The form of a closure is <code>(closure param-list body-exp environment)</code>.</p>
<p>Evaluation of the expression </p><div class="fragment"><div class="line">(lambda (x) (+ x 1))</div>
</div><!-- fragment --><p> results in the value </p><div class="fragment"><div class="line">(closure (x) (+ x 1) nil)</div>
</div><!-- fragment --><p> Below is an example of how a value is captured into the closure. </p><div class="fragment"><div class="line">(let ((a 1)) (lambda (x) (+ x a)))</div>
</div><!-- fragment --><p> The expression above evaluates to the following. Note that <code>(a . 1)</code> appears in the closure. </p><div class="fragment"><div class="line">(closure (x) (+ x a) ((a . 1)))</div>
</div><!-- fragment --><hr  />
<h2>let</h2>
<p>Local environments are created using let. The let binding in lispbm allows for mutually recursive bindings. The form of a let is <code>(let list-of-bindings body-expr)</code> and evaluating this expression means that body-expr is evaluted in an environment extended with the list-of-bindings.</p>
<p>Example that evaluates to 3. </p><div class="fragment"><div class="line">(let ((a 1)</div>
<div class="line">      (b 2))</div>
<div class="line">  (+ a b))</div>
</div><!-- fragment --><p> Below is a more advanced example of two mutually recursive functions created in a let binding. </p><div class="fragment"><div class="line">(let ((f (lambda (x) (if (= x 0) 0 (g (- x 1)))))</div>
<div class="line">      (g (lambda (x) (if (= x 0) 1 (f (- x 1))))))</div>
<div class="line">  (f 11))</div>
</div><!-- fragment --><p> The mutually recursive program above evaluates to 1.</p>
<hr  />
<p>Let supports deconstructive bindings. These are bindings that decompose a complex value into constituents.</p>
<p>Example:</p>
<div class="fragment"><div class="line">(let (( ( a . b) &#39;(1 . 2) ))</div>
<div class="line">   (+ a b))</div>
</div><!-- fragment --><p>In the example, the bindings a = 1 and b = 2 are created for use in the let body.</p>
<h2>loop</h2>
<p>loop allows to repeatedly evaluate an expression for as long as a condition holds. The form of a loop is <code>(loop list-of-local-bindings condition-exp body-exp)</code>.</p>
<p>The <code>list-of-local-bindings</code> are very similar to how <code>let</code> works, just that here the <code>body-exp</code> is repeated.</p>
<p>Example that prints hello world 5 times: </p><div class="fragment"><div class="line">(loop ( (a 5) ) (&gt; a 0) { (print &quot;hello world&quot;) (setq a (- a 1))})</div>
</div><!-- fragment --><p>When the <code>cond-exp</code> evaluates to false, the loop exits and the entire loop expression returns the value <code>nil</code>.</p>
<p>Here is an example of a "for each element in a list do something": </p><div class="fragment"><div class="line">(loop ( (a &#39;(1 2 3 4)) ) a { (print (car a)) (setq a (cdr a))})</div>
</div><!-- fragment --><p>The example above loops for as long as there are elements in a. Each element is printed and a is updated in the body.</p>
<h2>define</h2>
<p>You can give names to values in a global scope by using define. The form of define is <code>(define name expr)</code>. The expr is evaluated and it is the result of the evaluated expr that is stored in the environment. In lispbm you can redefine already defined values.</p>
<p>Example </p><h1>@code{clj} (define apa 10) @endcode </h1>
<h2>undefine</h2>
<p>A definition in the global can be removed using undefine. The form of an undefine expression is <code>(undefine name-expr)</code> where name-expr should evaluate to a symbol (for example <code>'apa</code>).</p>
<p>Example </p><div class="fragment"><div class="line">(undefine &#39;apa)</div>
</div><!-- fragment --><p>It is also possible to undefine several bindings at the same time by providing a list of names.</p>
<p>Example </p><div class="fragment"><div class="line">(undefine &#39;(apa bepa cepa))</div>
</div><!-- fragment --><hr  />
<h2>setvar</h2>
<p>The <code>setvar</code> form is used to change the value of some variable in an environment. You can use <code>setvar</code> to change the value of a global definition, a local definition or a variable defintion (<code>#var</code>). An application of the <code>setvar</code> form looks like <code>(setvar var-expr val-expr)</code> where <code>var-expr</code> should evaluate to a symbol. The <code>val-expr</code> is evaluated before rebinding the variable. <code>setvar</code> returns the value that <code>val-expr</code> evaluates to.</p>
<p>Examples: </p><div class="fragment"><div class="line">(define a 10)</div>
</div><!-- fragment --><p> The variable <code>a</code> is now <code>10</code> in the global environment. </p><div class="fragment"><div class="line">(setvar &#39;a 20)</div>
</div><!-- fragment --><p> Now, the value of <code>a</code> will be 20. Note that <code>a</code> is quoted in the <code>setvar</code> form application while it is not in the <code>define</code> form. This is because <code>define</code> requires the first argument to be a symbol while the <code>setvar</code> form requires the first argument to evaluate into a symbol.</p>
<p>You can also set the value of a let bound variable. </p><div class="fragment"><div class="line">(let ((a 10)) (setvar &#39;a 20))</div>
</div><!-- fragment --><p>And you can change the value of a <code>#var</code>.</p>
<div class="fragment"><div class="line">(define #a 10)</div>
<div class="line"> </div>
<div class="line">(setvar &#39;#a 20)</div>
</div><!-- fragment --><p> <code>#a</code> is now 20.</p>
<hr  />
<h2>set</h2>
<p>The <code>set</code> form is used to change the value of a variable in an environment. It behaves identical to <code>setvar</code>.</p>
<p>Example:</p>
<div class="fragment"><div class="line">(define a 10)</div>
</div><!-- fragment --><p> The variable <code>a</code> is now 10 in the global environment.</p>
<div class="fragment"><div class="line">(set &#39;a 20)</div>
</div><!-- fragment --><p>And now <code>a</code> is associated with 20 in the global environment.</p>
<p><code>set</code> works in local environments too such as in the body of a <code>let</code> or in a <code>progn</code>-local variable created using <code>var</code>.</p>
<p>Example:</p>
<div class="fragment"><div class="line">(progn (var a 10) (set &#39;a 20) a)</div>
</div><!-- fragment --><p>The expression above evaluates to 20.</p>
<h2>setq</h2>
<p>The <code>setq</code> special-form is similar to <code>set</code> and to <code>setvar</code> but expects the first argument to be a symbol. The first argument to <code>setq</code> is NOT evaluated.</p>
<p>Example: </p><div class="fragment"><div class="line">(define a 10)</div>
</div><!-- fragment --><p> The variable <code>a</code> is now 10 in the global environment.</p>
<div class="fragment"><div class="line">(setq a 20)</div>
</div><!-- fragment --><p>And now <code>a</code> has been associated with the value 20 in the global env.</p>
<p>Just like <code>set</code> and <code>setvar</code>, <code>setq</code> can be used on variables that are bound locally such as in the body of a <code>let</code> or a <code>progn</code>-local variable created using <code>var</code>.</p>
<h2>progn</h2>
<p>The progn special form allows you to sequence a number of expressions. The form of a progn expression is: </p><div class="fragment"><div class="line">(progn expr1</div>
<div class="line">       expr2</div>
<div class="line">       ...</div>
<div class="line">       exprN)</div>
</div><!-- fragment --><p> The evaluation result of a progn sequence is the value that the last <code>exprN</code> evaluated to. This is useful for sequencing of side-effecting operations.</p>
<p>Simple example that evaluates to 3: </p><div class="fragment"><div class="line">(progn 1</div>
<div class="line">       2</div>
<div class="line">       3)</div>
</div><!-- fragment --><p> An example where side effects are sequenced: </p><div class="fragment"><div class="line">(progn (define a 10)</div>
<div class="line">        (define b 20)</div>
<div class="line">        (+ a b))</div>
</div><!-- fragment --><p> This program evaluates 30 but also extends the global environment with the 2 bindings <code>(a 10)</code> and <code>(b 20)</code> created using <a href="#define">define</a>.</p>
<hr  />
<h2>{</h2>
<p>The curlybrace <code>{</code> syntax is a short-form (syntactic sugar) for <code>(progn</code>. The parser replaces occurrences of <code>{</code> with <code>(progn</code>. The <code>{</code> should be closed with an <code>}</code>.</p>
<p>These two programs are thus equivalent:</p>
<div class="fragment"><div class="line">(progn</div>
<div class="line">  (define a 10)</div>
<div class="line">  (define b 20)</div>
<div class="line">  (+ a b))</div>
</div><!-- fragment --><p>And</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  (define a 10)</div>
<div class="line">  (define b 20)</div>
<div class="line">  (+ a b)</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h2>}</h2>
<p>The closing curlybrace <code>}</code> should be used to close an opening <code>{</code> but purely for esthetical reasons. The <code>}</code> is treated identically to a regular closing parenthesis <code>)</code>.</p>
<p>The opening <code>{</code> and closing <code>}</code> curlybraces are used as a short-form for <code>progn</code>-blocks of sequences expressions.</p>
<h2>var</h2>
<p>The var special form allows local bindings in a progn expression. A var expression is of the form (var symbol expr) and the symbol <code>symbol</code> is bound to the value that <code>expr</code> evaluates to withing the rest of the progn expression.</p>
<p>Example:</p>
<div class="fragment"><div class="line">(defun f ()</div>
<div class="line">  (progn</div>
<div class="line">    (var a 10)</div>
<div class="line">    (var b 20)</div>
<div class="line">    (+ a b)))</div>
</div><!-- fragment --><p>and:</p>
<div class="fragment"><div class="line">(defun f ()</div>
<div class="line">  (progn</div>
<div class="line">    (var a 10)</div>
<div class="line">    (var b (+ a 10))</div>
<div class="line">    (+ a b)))</div>
</div><!-- fragment --><h2>read</h2>
<p>Parses a string resulting in either an expression or the <a href="#read_error">read_error</a> in case the string can not be parsed into an expression. The form of a read expression is <code>(read string)</code>.</p>
<p>The example below evaluates to the value 1: </p><div class="fragment"><div class="line">(read &quot;1&quot;)</div>
</div><!-- fragment --><p> You can also read code: </p><div class="fragment"><div class="line">(read &quot;(lambda (x) (+ x 1))&quot;)</div>
</div><!-- fragment --><p> That lambda you just read in from a string can be directly applied to an argument if using an application of eval to evaluate the read lambda into a closure. </p><div class="fragment"><div class="line">((eval (read &quot;(lambda (x) (+ x 1))&quot;)) 10)</div>
</div><!-- fragment --><p> The code above evaluates to 11.</p>
<hr  />
<p><a class="anchor" id="read-program"></a> </p><h3>read-program</h3>
<p>Parses a string containing multiple sequenced expressed. The resulting list of expressions can be evaluated as a program using <a href="#eval-program">eval-program</a>. The form of a read-program expression is <code>(read-program string)</code>.</p>
<p>Evaluate a program you just read from a string with <a href="#eval-program">eval-program</a>. </p><div class="fragment"><div class="line">(eval-program (read-program &quot;(define apa 1) (+ 2 apa)&quot;))</div>
</div><!-- fragment --><p> The expression above evaluates to 3 with the side effect that the global environment has been extended with the binding <code>(apa 1)</code>.</p>
<hr  />
<h2>read-eval-program</h2>
<p>Parses and evaluates a program incrementally. <code>read-eval-program</code> reads a top-level expression then evaluates it before reading the next.</p>
<p>Example that evaluates to 20:</p>
<div class="fragment"><div class="line">(read-eval-program &quot;(define a 10) (+ a 10)&quot;)</div>
</div><!-- fragment --><p><code>read-eval-program</code> supports the <code>@const-start</code>, <code>@const-end</code> which moved all global definitions created in the program to constant memory (flash).</p>
<p>Example that evaluates to 20:</p>
<h1>@code{clj} (read-eval-program "@const-start (define a 10) (+ a 10) @const-end") @endcode </h1>
<h1>Lists and cons cells</h1>
<p>Lists are built using cons cells. A cons cell is represented by the <a class="el" href="structlbm__cons__t.html">lbm_cons_t</a> struct in the implementation and consists of two fields named the <code>car</code> and the <code>cdr</code>. There is no special meaning associated with the <code>car</code> and the <code>cdr</code> each can hold a lbm_value. See <a href="#cons">cons</a> and <a href="#list">list</a> for two ways to create structures of cons cells on the heap.</p>
<p><img src="images/cons_cell.png?raw=true" alt="cons cell" title="cons cell" class="inline"/></p>
<p>A cons cell can be used to store a pair of values. You create a pair by sticking a value in both the car and cdr field of a cons cell using either &lsquo;&rsquo;(1 . 2)<code>or </code>(cons 1 2)`.</p>
<p><img src="images/pair.png?raw=true" alt="pair" title="pair" class="inline"/></p>
<p>A list is a number of cons cells linked together where the car fields hold values and the cdr fields hold pointers (the last cdr field is nil). The list below can be created either as &lsquo;&rsquo;(1 2 3)<code>or as</code>(list 1 2 3)`.</p>
<p><img src="images/list.png?raw=true" alt="list" title="pair" class="inline"/></p>
<h2>car</h2>
<p>Use <code>car</code> to access the <code>car</code> field of a cons cell. A <code>car</code> expression has the form <code>(car expr)</code>.</p>
<p>Taking the <code>car</code> of a number of symbol type is in general a <a href="#type_error">type_error</a>. The following program results in <code>type_error</code>. </p><div class="fragment"><div class="line">(car 1)</div>
</div><!-- fragment --><p> The next example evaluates to 1. </p><div class="fragment"><div class="line">(car (cons 1 2))</div>
</div><!-- fragment --><p> The <code>car</code> operation accesses the head element of a list. The following program evaluates to 9. </p><div class="fragment"><div class="line">(car (list 9 8 7))</div>
</div><!-- fragment --><hr  />
<h2>first</h2>
<p><code>first</code> is an alternative (and one that makes some sense) name for the <code>car</code> operation.</p>
<p>Use <code>first</code> to access the first element of a list or pair. A <code>first</code> expression has the form <code>(first expr)</code>.</p>
<div class="fragment"><div class="line"># (first (list 1 2 3 4))</div>
<div class="line">&gt; 1</div>
</div><!-- fragment --><hr  />
<h2>cdr</h2>
<p>Use <code>cdr</code> to access the <code>cdr</code> field of a cons cell. A <code>cdr</code> expression has the form <code>(cdr expr)</code>.</p>
<p>The example below evaluates to 2. </p><div class="fragment"><div class="line">(cdr (cons 1 2))</div>
</div><!-- fragment --><p> The <code>cdr</code> operation gives you the rest of a list. The example below evaluates to the list (8 7). </p><div class="fragment"><div class="line">(cdr (list 9 8 7))</div>
</div><!-- fragment --><hr  />
<h2>rest</h2>
<p><code>rest</code> is an alternative name for the <code>cdr</code> operation.</p>
<p>Use <code>rest</code> to access all elements except the first one of a list, or to access the second element in a pair. A <code>rest</code> expression has the form <code>(rest expr)</code>.</p>
<div class="fragment"><div class="line"># (rest (list 1 2 3 4))</div>
<div class="line">&gt; (2 3 4)</div>
</div><!-- fragment --><hr  />
<h2>cons</h2>
<p>The <code>cons</code> operation allocates a cons cell from the heap and populates the <code>car</code> and the <code>cdr</code> fields of this cell with its two arguments. The form of a <code>cons</code> expression is <code>(cons expr1 expr2)</code>.</p>
<p>Build the list <code>(1 2 3)</code> using cons. <a href="#nil">nil</a> terminates a proper list. </p><div class="fragment"><div class="line">(cons 1 (cons 2 (cons 3 nil)))</div>
</div><!-- fragment --><p> Construct the pair <code>(+ . 1)</code> using cons. </p><div class="fragment"><div class="line">(cons + 1)</div>
</div><!-- fragment --><hr  />
<h2>.</h2>
<p>The dot, <code>.</code>, operation creates a pair. The form of a dot expression is <code>(expr1 . expr2)</code>. By default the evaluator will attempt to evaluate the result of <code>(expr1 . expr2)</code> unless it is prefixed with &lsquo;&rsquo;`.</p>
<p>Example that creates the pair (1 . 2) </p><div class="fragment"><div class="line">&#39;(1 . 2)</div>
</div><!-- fragment --><hr  />
<h2>list</h2>
<p>The <code>list</code> function is used to create proper lists. The function takes n arguments and is of the form <code>(list expr1 ... exprN)</code>.</p>
<p>Example that creates the list (1 2 3 4). </p><div class="fragment"><div class="line">(list 1 2 3 4)</div>
</div><!-- fragment --><hr  />
<h2>length</h2>
<p>Computes the length of a list. The <code>length</code> function takes one argument and is of the form <code>(length expr)</code>.</p>
<p>Example that evaluates to 4 </p><div class="fragment"><div class="line">(length (list 1 2 3 4))</div>
</div><!-- fragment --><hr  />
<h2>range</h2>
<p>The <code>range</code> function computes a list with integer values from a range specified by its endpoints. The form of a range expression is <code>(range start-expr end-expr)</code>. The end point in the range is excluded.</p>
<p>Example that generates the list (4 5 6 7). </p><div class="fragment"><div class="line">(range 4 8)</div>
</div><!-- fragment --><p>A range specified with the end-point being smaller than the starting point is in descending order.</p>
<p>Example that generates the list (7 6 5 4). </p><div class="fragment"><div class="line">(range 8 4)</div>
</div><!-- fragment --><p>Negative number can be used to specify a range</p>
<p>Example that generates the list (-10 -9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9) </p><div class="fragment"><div class="line">(range -10 10)</div>
</div><!-- fragment --><hr  />
<h2>append</h2>
<p>The <code>append</code> function combines two lists into a longer list. An <code>append</code> expression is of the form <code>(append expr1 expr2)</code>.</p>
<p>Example that combines to lists. </p><div class="fragment"><div class="line">(append (list 1 2 3) (list 4 5 6))</div>
</div><!-- fragment --><hr  />
<h2>ix</h2>
<p>Index into a list using the <code>ix</code>. the form of an <code>ix</code> expression is <code>(ix list-expr index-expr)</code>. Indexing starts from 0 and if you index out of bounds the result is nil.</p>
<p>Example that evaluates to 2. </p><div class="fragment"><div class="line">(ix (list 1 2 3) 1)</div>
</div><!-- fragment --><hr  />
<h2>setix</h2>
<p>Destructively update an element in a list. The form of a <code>setix</code> expression is <code>(setix list-expr index-extr value-expr)</code>. Indexing starts from 0 and if you index out of bounds the result is nil.</p>
<div class="fragment"><div class="line"># (setix (list 1 2 3 4 5) 2 77)</div>
<div class="line">&gt; (1 2 77 4 5)</div>
</div><!-- fragment --><hr  />
<h2>setcar</h2>
<p>The <code>setcar</code> is a destructive update of the car field of a cons-cell.</p>
<p>Define <code>apa</code> to be the pair <code>(1 . 2)</code> </p><div class="fragment"><div class="line">(define apa &#39;(1 . 2))</div>
</div><!-- fragment --><p> Now change the value in the car field of apa to 42. </p><div class="fragment"><div class="line">(setcar apa 42)</div>
</div><!-- fragment --><p> The <code>apa</code> pair is now <code>(42 . 2)</code>.</p>
<hr  />
<h2>setcdr</h2>
<p>The <code>setcdr</code> is a destructive update of the cdr field of a cons-cell.</p>
<p>Define <code>apa</code> to be the pair <code>(1 . 2)</code> </p><div class="fragment"><div class="line">(define apa &#39;(1 . 2))</div>
</div><!-- fragment --><p> Now change the value in the cdr field of apa to 42. </p><div class="fragment"><div class="line">(setcdr apa 42)</div>
</div><!-- fragment --><p> The <code>apa</code> pair is now <code>(1 . 42)</code>.</p>
<hr  />
<h2>take</h2>
<p><code>take</code> creates a list containing the <code>n</code> first elements of another list. The form of a <code>take</code> expression is <code>(take list-exp n-exp)</code>.</p>
<p>Example that takes 5 elements from a list: </p><div class="fragment"><div class="line">(define ls (list 1 2 3 4 5 6 7 8 9 10))</div>
<div class="line"> </div>
<div class="line">(take ls 5)</div>
</div><!-- fragment --><p>In the example above, the result of <code>(take ls 5)</code> is <code>(1 2 3 4 5)</code>.</p>
<hr  />
<h2>drop</h2>
<p><code>drop</code> creates a list from another list by dropping the <code>n</code> first elements of that list. The form of a <code>drop</code> expression is <code>(drop list-exp n-exp)</code>.</p>
<p>Example that drops 5 elements from a list: </p><div class="fragment"><div class="line">(define ls (list 1 2 3 4 5 6 7 8 9 10))</div>
<div class="line"> </div>
<div class="line">(drop ls 5)</div>
</div><!-- fragment --><p>Here <code>(drop ls 5)</code> evaluates to the list <code>(6 7 8 9 10)</code>.</p>
<hr  />
<h2>Merge</h2>
<p><code>merge</code> merges two lists that are ordered according to a comparator into a single ordered list. The form of a <code>merge</code> expression is <code>(merge comparator-exp list-exp1 list-exp2)</code>.</p>
<p>Example: </p><div class="fragment"><div class="line">(define a &#39;(2 4 6 8 10 12))</div>
<div class="line">(define b &#39;(1 3 5))</div>
<div class="line"> </div>
<div class="line">(merge &lt; a b)</div>
</div><!-- fragment --><p>Here <code>(merge &lt; a b)</code> evaluates to the list <code>(1 2 3 4 5 6 8 10 12)</code>.</p>
<hr  />
<h2>Sort</h2>
<p><code>sort</code> orders a list of values according to a comparator. The sorting algorithm used is an in-place merge-sort. A copy of the input list is created at the beginning of the sort to provide a functional interface from the user's point of view. The form of a sort expression is <code>(sort comparator-exp list-exp)</code></p>
<p>Example: </p><div class="fragment"><div class="line">(define ls &#39;( 1 9 2 5 1 8 3))</div>
<div class="line"> </div>
<div class="line">(sort &lt; ls)</div>
</div><!-- fragment --><p>Here <code>(sort &lt; ls)</code> evaluates to the list <code>(1 1 2 3 5 8 9)</code>.</p>
<hr  />
<h1>Associations lists (alists)</h1>
<p>Association lists (alists) are, just like regular lists, built out of cons-cells. The difference is that an alist is a list of pairs where the first element in each par can be thought of as a key and the second element can be thought of as the value. So alists implement a key-value lookup structure.</p>
<p>&lsquo;(list &rsquo;(1 . horse) '(2 . donkey) '(3 . shark))` is an example of an alist with integer keys and symbol values.</p>
<h2>acons</h2>
<p>The <code>acons</code> form is similar to <code>cons</code>, it attaches one more element onto an alist. The element that is added consists of a key and a value so <code>acons</code> takes one more argument than <code>cons</code>. The form of an <code>acons</code> expression is <code>(acons key-expr val-expr alist-expr)</code>. The <code>alist-expr</code> should evaluate to an alist but there are no checks to ensure this.</p>
<p>Example that adds the key <code>4</code> and associated value <code>lemur</code> to an existing alist.</p>
<div class="fragment"><div class="line"># (acons 4 &#39;lemur (list &#39;(1 . horse) &#39;(2 . donkey) &#39;(3 . shark)))</div>
<div class="line">&gt; ((4 . lemur) (1 . horse) (2 . donkey) (3 . shark))</div>
</div><!-- fragment --><hr  />
<h2>assoc</h2>
<p>The <code>assoc</code> function looks up the first value in an alist matching a given a key. The form of an <code>assoc</code> expression is <code>(assoc alist-expr key-expr)</code></p>
<p>Example that looks up the value of key <code>2</code> in an alist. </p><div class="fragment"><div class="line"># (assoc (list &#39;(1 . horse) &#39;(2 . donkey) &#39;(3 . shark)) 2)</div>
<div class="line">&gt; donkey</div>
</div><!-- fragment --><hr  />
<h2>cossa</h2>
<p>The <code>cossa</code> function looks up the first key in an alist that matches a given value. The form of an <code>cossa</code> expression is <code>(cossa alist-expr value-expr)</code></p>
<p>Example that looks up the key for the value <code>donkey</code> in an alist. </p><div class="fragment"><div class="line"># (cossa (list &#39;(1 . horse) &#39;(2 . donkey) &#39;(3 . shark)) &#39;donkey)</div>
<div class="line">&gt; 2</div>
</div><!-- fragment --><hr  />
<h2>setassoc</h2>
<p>The <code>setassoc</code> function destructively updates a key-value mapping in an alist. The form of a <code>setassoc</code> expression is <code>(setassoc alist-expr key-expr value-expr)</code>.</p>
<h1>Arrays (byte-buffers)</h1>
<h2>bufcreate</h2>
<p>Create an array of bytes. The form of an <code>bufcreate</code> expression is <code>(bufcreate size-expr)</code></p>
<p>Example that creates a 10 element buffer caled data:</p>
<div class="fragment"><div class="line">(define data (bufcreate 10))</div>
</div><!-- fragment --><p>Use the buffer extensions to operate <code>data</code>. See the <a href="https://github.com/vedderb/bldc/tree/master/lispBM#byte-arrays">VESC</a> lbm documentation for details on operations on buffers.</p>
<hr  />
<h2>buflen</h2>
<p>Returns the size of a buffer in number of bytes. The form of an <code>buflen</code> expression is <code>(buflen buf-expr)</code> where buf-expr has to evaluate into a buffer.</p>
<hr  />
<h2>bufget-[X]</h2>
<p>Read a value from a buffer. The contents of a buffer can be read as a sized integer or unsigned value using as many bytes from the buffer as the X portion of the function name implies. The form of a bufget expression is <code>(bufget-[X] buf-expr ix-expr)</code> where <code>ix-expr</code> evaluates to a number indicating the byte position to start reading from.</p>
<ul>
<li><code>bufget-i8</code></li>
<li><code>bufget-i16</code></li>
<li><code>bufget-i24</code></li>
<li><code>bufget-i32</code></li>
<li><code>bufget-u8</code></li>
<li><code>bufget-u16</code></li>
<li><code>bufget-u24</code></li>
<li><code>bufget-u32</code></li>
</ul>
<p>Example that reads an u8 from a buffer at position 1:</p>
<div class="fragment"><div class="line">(define buf [1 2 3 4])</div>
<div class="line"> </div>
<div class="line">(bufget-u8 buf 1)</div>
</div><!-- fragment --><hr  />
<h2>bufset-[X]</h2>
<p>The <code>bufset</code> functions performs a destructive updates to a buffer. The form of a <code>bufset</code> expression is <code>(bufset-[X] buf-expr ix-expr val-expr)</code> where <code>ix-expr</code> evaluates to a number indicating where in the buffer to start writing and <code>val-expr</code> is the value to write.</p>
<ul>
<li><code>bufset-i8</code></li>
<li><code>bufset-i16</code></li>
<li><code>bufset-i24</code></li>
<li><code>bufset-i32</code></li>
<li><code>bufset-u8</code></li>
<li><code>bufset-u16</code></li>
<li><code>bufset-u24</code></li>
<li><code>bufset-u32</code></li>
</ul>
<p>Example that updates position 1 in a buffer:</p>
<div class="fragment"><div class="line">(define buf [1 2 3 4])</div>
<div class="line"> </div>
<div class="line">(bufset-u8 buf 1 100)</div>
</div><!-- fragment --><hr  />
<h2>bufclear</h2>
<p>To clear a byte array the function bufclear can be used:</p>
<div class="fragment"><div class="line">(bufclear arr optByte optStart optLen)</div>
</div><!-- fragment --><p>Where arr is the byte array to clear, optByte is the optional argument of what to clear with (default 0), optStart is the optional argument of which position to start clearing (default 0) and optLen is the optional argument of how many bytes to clear after start (default the entire array). Example:</p>
<h1>@code{clj} (bufclear arr) ; Clear all of arr (bufclear arr 0xFF) ; Fill arr with 0xFF (bufclear arr 0 5) ; Clear from index 5 to the end (bufclear arr 0 5 10) ; Clear 10 bytes starting from index 5 (bufclear arr 0xAA 5 10) ; Set 10 bytes to 0xAA starting from index 5 @endcode </h1>
<h2>Byte-array literal syntax</h2>
<p>Byte-array (buffer) literals can be created using the <code>[</code> and <code>]</code> syntax to enclose values to initialize the array with. The <code>[</code> and <code>]</code> syntax is complete resolved in the parser and thus cannot contain arbitrary lisp terms. the values listed between the <code>[</code> and the <code>]</code> must be literals!</p>
<p>The form of the <code>[</code> and <code>]</code> syntax is <code>[ val1 ... valN ]</code>.</p>
<p>Example that creates a byte array </p><div class="fragment"><div class="line">[ 1 2 3 4 5 6 7 8 9 10 ]</div>
</div><!-- fragment --><hr  />
<h1>Pattern-matching</h1>
<h2>match</h2>
<p>Pattern-matching is expressed using match. The form of a match expression is <code>(match expr (pat1 expr1) ... (patN exprN))</code>. Pattern-matching compares the shape of an expression to each of the <code>pat1</code> ... <code>patN</code> and evaluates the expression <code>exprM</code> of the pattern that matches. In a pattern you can use a number of match-binders or wildcards: <code>_</code>, <code>?</code>, <code>?i</code>,<code>?u</code>,<code>?float</code>.</p>
<p>For example the match expression below evaluates to 2. </p><div class="fragment"><div class="line">(match &#39;orange</div>
<div class="line">       (green 1)</div>
<div class="line">       (orange 2)</div>
<div class="line">       (blue 3))</div>
</div><!-- fragment --><hr  />
<h2>no_match</h2>
<p>The <code>no_match</code> symbol is returned from pattern matching if no case matches the expression. </p><pre class="fragment">- Add a catch-all case to your pattern-matching. `_`.
</pre> <hr  />
<h2>_</h2>
<p>The underscore pattern matches anything.</p>
<p>An example that evaluates to <code>i-dont-know</code> </p><div class="fragment"><div class="line">(match &#39;fish</div>
<div class="line">       (horse &#39;its-a-horse)</div>
<div class="line">       (pig &#39;its-a-pig)</div>
<div class="line">       (_ &#39;i-dont-know))</div>
</div><!-- fragment --><hr  />
<h2>?</h2>
<p>The <code>?</code> pattern matches anything and binds that anything to variable. Using the <code>?</code> pattern is done as <code>(? var)</code> and the part of the expression that matches is bound to <code>var</code>.</p>
<p>An example that evaluates to 19. </p><div class="fragment"><div class="line">(match &#39;(orange 17)</div>
<div class="line">       ((green (? n)) (+ n 1))</div>
<div class="line">       ((orange (? n)) (+ n 2))</div>
<div class="line">       ((blue (? n)) (+ n 3)))</div>
</div><!-- fragment --><hr  />
<h2>Match with guards</h2>
<p>Patterns used in a match expressions can be augmented with a boolean guard to further discern between cases. A pattern with a guard is of the form <code>(pattern-expr guard-expr expr)</code>. A pattern with a guard, matches only if the pattern structurally matches and if the guard-expr evaluates to true in the match environment.</p>
<p>Example: </p><div class="fragment"><div class="line">(match (x)</div>
<div class="line">       ( (? y) (&lt; y 0) &#39;less-than-zero)</div>
<div class="line">       ( (? y) (&gt; y 0) &#39;greater-than-zero)</div>
<div class="line">       ( (? y) (= y 0) &#39;equal-to-zero))</div>
</div><!-- fragment --><hr  />
<h1>Concurrency</h1>
<p>The concurrency support in LispBM is provided by the set of functions, <code>spawn</code>, <code>wait</code>, <code>yeild</code> and <code>atomic</code> described below. Concurrency in LispBM is scheduled by a round-robin scheduler that splits the runtime system evaluator fairly (with caveats, below) between all running processes.</p>
<p>When a process is scheduled to run, made active, it is given a quota of evaluator "steps" to use up. The process then runs until that quota is exhausted or the process itself has signaled it wants to sleep by yielding or blocking (for example by waiting for a message using the message passing system).</p>
<p>A process can also request to not be "pre-empted" while executing a certain expression by invoking <code>atomic</code>. One should take care to make blocks of atomic code as small as possible as it disrupts the fairness of the scheduler. While executing inside of an atomic block the process has sole ownership of the shared global environment and can perform atomic read-modify-write sequences to global data.</p>
<h2>spawn</h2>
<p>Use <code>spawn</code> to launch a concurrent process. Spawn takes a closure and arguments to pass to that closure as its arguments. The form of a spawn expression is <code>(spawn opt-name opt-stack-size closure arg1 ... argN)</code>.</p>
<p>Each process has a runtime-stack which is used for the evaluation of expressions within that process. The stack size needed by a process depends on</p><ol type="1">
<li>How deeply nested expressions evaluated by the process are.</li>
<li>Number of recursive calls (Only if a function is NOT tail-recursive).</li>
<li>The Number of arguments that functions called by the process take.</li>
</ol>
<p>Having a stack that is too small will result in a <code>out_of_stack</code> error.</p>
<p>The default stack size is 256 words (1K Bytes) and should be more than enough for reasonable programs. Many processes will work perfectly fine with a lot less stack. You can find a good size by trial and error.</p>
<hr  />
<h2>spawn-trap</h2>
<p>Use <code>spawn-trap</code> to spawn a child process and enable trapping of exit conditions for that child. The form of a <code>spawn-trap</code> expression is <code>(spawn-trap opt-name opt-stack-size closure arg1 .. argN)</code>. If the child process is terminated because of an error, a message is sent to the parent process of the form <code>(exit-error tid err-val)</code>. If the child process terminates successfully a message of the form <code>(exit-ok tid value)</code> is sent to the parent.</p>
<p>Example: </p><div class="fragment"><div class="line">(spawn-trap my-thread)</div>
<div class="line"> </div>
<div class="line">(recv  ((exit-error (? tid) (? e)) ...)</div>
<div class="line">       ((exit-ok    (? tid) (? v)) ...))</div>
</div><!-- fragment --><hr  />
<h2>self</h2>
<p>Use <code>self</code> to obtain the thread-id of the thread in which <code>self</code> is evaluated. The form of a <code>self</code> expression is <code>(self)</code>. The thread id is of an integer type.</p>
<p>Example: </p><h1>@code{clj} # (self) &gt; 314 @endcode </h1>
<h2>wait</h2>
<p>Use <code>wait</code> to wait for a spawned process to finish. The argument to <code>wait</code> should be a process id. The <code>wait</code> blocks until the process with the given process id finishes. When the process with with the given id finishes, the wait function returns True.</p>
<p>Be careful to only wait for processes that actually exist and do finish. Otherwise you will wait forever.</p>
<hr  />
<h2>yield</h2>
<p>To put a process to sleep, call <code>yield</code>. The argument to <code>yield</code> is number indicating at least how many microseconds the process should sleep.</p>
<hr  />
<h2>atomic</h2>
<p><code>atomic</code> can be used to execute a LispBM one or more expression without allowing the runtime system to switch process during that time.</p>
<p>An example that atomically perfoms operations a,b and c.</p>
<h1>@code{clj} (atomic a b c) @endcode </h1>
<h2>exit-ok</h2>
<p>The <code>exit-ok</code> function terminates the thread in a "successful" way and returnes a result specified by the programmer. The form of an <code>exit-ok</code> expression is <code>(exit-ok value)</code>. If the process that calls <code>exit-ok</code> was created using <code>spawn-trap</code> a message of the form <code>(exit-ok tid value)</code> is be sent to the parent of this process.</p>
<hr  />
<h2>exit-error</h2>
<p>The <code>exit-error</code> function terminates the thread with an error specified by the programmer. The form of an <code>exit-error</code> expression is <code>(exit-error err_val)</code>. If the process that calls <code>exit-error</code> was created using <code>spawn-trap</code> a message of the form <code>(exit-error tid err_val)</code> is sent to the parent of this process.</p>
<hr  />
<h1>Message-passing</h1>
<h2>send</h2>
<p>Messages can be sent to a process by using <code>send</code>. The form of a <code>send</code> expression is <code>(send pid msg)</code>. The message, msg, can be any LispBM value.</p>
<hr  />
<h2>recv</h2>
<p>To receive a message use the <code>recv</code> command. A process will block on a <code>recv</code> until there is a matching message in the mailbox. The <code>recv</code> syntax is very similar to <a href="./lbmref.md#match">match</a>.</p>
<p>Example where a process waits for an integer <code>?i</code>. </p><div class="fragment"><div class="line">(recv ( (?i n) (+ n 1) ))</div>
</div><!-- fragment --><hr  />
<h2>recv-to</h2>
<p>Like <a href="./lbmref.md#recv">recv</a>, <code>recv-to</code> is used to receive messages but <code>recv-to</code> takes an extra timeout argument.</p>
<p>The form of an <code>recv-to</code> expression is </p><div class="fragment"><div class="line">(recv-to timeout-secs</div>
<div class="line">                (pattern1 exp1)</div>
<div class="line">                ...</div>
<div class="line">                (patternN expN))</div>
</div><!-- fragment --><p>If no message is received before the timout, the message <code>timeout</code> is delivered to the waiting process. This <code>timeout</code> message can be handled in one of the receive patterns.</p>
<p>Example </p><div class="fragment"><div class="line">(recv-to 0.5</div>
<div class="line">         ( timeout (handle-timeout))</div>
<div class="line">         ( _       (do-something-else)))</div>
</div><!-- fragment --><hr  />
<h2>set-mailbox-size</h2>
<p>Change the size of the mailbox in the current process. Standard mailbox size is 10 elements.</p>
<p>Example that changes mailbox size to 100 elements. </p><div class="fragment"><div class="line">(set-mailbox-size 100)</div>
</div><!-- fragment --><hr  />
<h1>Flat values</h1>
<p>Lisp values can be "flattened" into an array representation. The flat representation of a value contains all information needed so that the value can be recreated, "unflattened", in another instance of the runtime system (for example running on another microcontroller).</p>
<p>Not all values can be flattened, custom types for example cannot.</p>
<h2>flatten</h2>
<p>The <code>flatten</code> function takes a value as single argument and returns the flat representation if successful. A flatten expression has the form <code>(flatten expr)</code>. Note that <code>expr</code> is evaluated before the flattening.</p>
<p>Example: </p><div class="fragment"><div class="line"># (define a (flatten (+ 1 2)))</div>
<div class="line">&gt; &quot;&#x2405;&quot;</div>
</div><!-- fragment --><p> The example above creates a byte-array representating the the value <code>3</code>.</p>
<div class="fragment"><div class="line"># (define a (flatten &#39;(+ 1 2)))</div>
<div class="line">&gt; &quot;&#x2403;+&quot;</div>
</div><!-- fragment --><p>Now the byte-array contains a representation of the list <code>(+ 1 2)</code></p>
<hr  />
<h2>unflatten</h2>
<p><code>unflatten</code> converts a flat value back into a lisp value. Te form of an <code>unflatten</code> expression is <code>(unflatten flat-value)</code></p>
<p>Example: </p><div class="fragment"><div class="line"># (define a (flatten (+ 1 2)))</div>
<div class="line">&gt; &quot;&#x2405;&quot;</div>
<div class="line"># (unflatten a)</div>
<div class="line">&gt; 3</div>
</div><!-- fragment --><p>and:</p>
<div class="fragment"><div class="line"># (define a (flatten &#39;(+ 1 2)))</div>
<div class="line">&gt; &quot;&#x2403;+&quot;</div>
<div class="line"># (unflatten a)</div>
<div class="line">&gt; (+ 1 2)</div>
</div><!-- fragment --><h1>Macros</h1>
<p>lispBM macros are created using the <code>macro</code> keyword. A macro is quite similar to <a href="./lbmref.mb#lambda">lambda</a> in lispBM except that arguments are passed in unevaluated. Together with the code-splicing capabilities given by <a href="./lbmref.md#quasiquotation">quasiquotation</a>, this provides a powerful code-generation tool.</p>
<p>A macro application is run through the interpreter two times. Once to evaluate the body of the macro on the unevaluated arguments. The result of this first application should be a program. The resulting program then goes through the interpreter again to compute final values.</p>
<p>Given this repeated evaluation, macros are not a performance boost in lispbm. Macros are really a feature that should be used to invent new programming abstractions in cases where it is ok to pay a little for the overhead for benefits in expressivity.</p>
<h2>macro</h2>
<p>The form of a <code>macro</code> expression is: <code>(macro args body)</code></p>
<p>Some lisps provide a <code>defun</code> operation for defining functions with a bit less typing. The example below defines a <code>defun</code> macro. </p><div class="fragment"><div class="line">(define defun (macro (name args body)</div>
<div class="line">                     `(define ,name (lambda ,args ,body))))</div>
</div><!-- fragment --><p> With this macro the function <code>inc</code> that adds 1 to its argument can be defined as: </p><div class="fragment"><div class="line">(defun inc (x) (+ x 1))</div>
</div><!-- fragment --><hr  />
<h1>Call With Current Continuation</h1>
<p>"Call with current continuation" is called <code>call-cc</code> in LBM. Call with current continuation saves the "current continuation", which encodes what the evaluator will do next, into an object in the language. This encoded continuation object behaves as a function taking one argument.</p>
<p>The <code>call-cc</code> should be given a function, <code>f</code>, as the single argument. This function, <code>f</code>, should also take a single argument, the continuation. At any point in the body of <code>f</code> the continuation can be applied to a value, in essense replacing the entire <code>call-cc</code> with that value. All side-effecting operations operations up until the application of the continuation will take effect.</p>
<p>From within a <code>call-cc</code> application it is possible to bind the continuation to a global variable which will allow some pretty arbitrary control flow.</p>
<p>The example below creates a macro for a <code>progn</code> facility that allows returning at an arbitrary point. </p><div class="fragment"><div class="line">(define do (macro (body)</div>
<div class="line">                  `(call-cc (lambda (return) (progn ,@body)))))</div>
</div><!-- fragment --><p> The example using <code>do</code> below makes use of <code>print</code> which is not a built-in feature of lispBM. There are just to many different ways a programmer may want to implement <code>print</code> on an microcontroller. Use the lispBM extensions framework to implement your own version of <code>print</code> </p><div class="fragment"><div class="line">(do ((print 10)</div>
<div class="line">     (return &#39;t)</div>
<div class="line">     (print 20)))</div>
</div><!-- fragment --><p> In the example above only "10" will be printed. Below is an example that conditionally returns. </p><div class="fragment"><div class="line">(define f (lambda (x)</div>
<div class="line">            (do ((print &quot;hello world&quot; \#newline)</div>
<div class="line">                 (if (= x 1)</div>
<div class="line">                     (return &#39;t)</div>
<div class="line">                     nil)</div>
<div class="line">                 (print &quot;Gizmo!&quot; \#newline)))))</div>
</div><!-- fragment --><hr  />
<h1>Error handling</h1>
<p>If an error occurs while evaluating a program, the process that runs that program is killed. The result of the killed process is set to an error symbol indicating what went wrong.</p>
<p>If the process was created using <code>spawn</code> (or equivalently, started by a issuing a command in the repl), the process dies and an error message is presented over the registered printing callback (dependent on how LispBM is integrated into your system). The <code>ctx_done_callback</code> is also called and performs other integration dependent tasks related to the shutting down of a process.</p>
<p>If the process was created using <code>spawn-trap</code>, in addition to the above, a message is sent to the parent process (the process that executed the spawn-trap) containing information about the process that struck an error. See <a href="#spawn-trap">spawn-trap</a>. The parent process can now choose to restart the process that crashed or to take some other action.</p>
<hr  />
<h1>Error Symbols</h1>
<h2>read_error</h2>
<p>The <code>read_error</code> symbol is returned if the reader cannot parse the input code.</p>
<p>Read errors are most likely caused by syntactically incorrect input programs. </p><pre class="fragment">- Check that all opening parenthesis are properly closed.
</pre> <hr  />
<h2>type_error</h2>
<p>The <code>type_error</code> symbol is returned by built-in functions or extensions if the values passed in are of incompatible types.</p>
<hr  />
<h2>eval_error</h2>
<p>The <code>eval_error</code> symbol is returned if evaluation could not proceed to evaluate the expression. This could be because the expression is malformed.</p>
<p>Evaluation error happens on programs that may be syntactically correct (LispBM has a very low bar for what is considered syntactically correct), but semantically nonsensical. </p><pre class="fragment">- Check the program for mistakes.
- Are your parenthesis enclosing the correct subterms?
- Check that you haven't written, for example, (1 + 2) where it should be (+ 1 2).
</pre> <hr  />
<h2>out_of_memory</h2>
<p>The <code>out_of_memory</code> symbol is returned if the heap is full and running the garbage collector was not able to free any memory up.</p>
<p>The program you have written requires more memory. </p><pre class="fragment">- Increase the heap size.
- Rewrite the application to use less memory.
</pre> <hr  />
<h2>fatal_error</h2>
<p>The <code>fatal_error</code> symbol is returned in cases where the LispBM runtime system cannot proceed. Something is corrupt and it is not safe to continue. </p><pre class="fragment">- If this happens please send the program and the full error message
  to blog.joel.svensson@gmail.com. It will be much appreciated.
</pre> <hr  />
<h2>out_of_stack</h2>
<p>The <code>out_of_stack</code> symbol is returned if the evaluator runs out of continuation stack (this is its runtime-stack). You are most likely writing a non-tail-recursive function that is exhausting all the resources. </p><pre class="fragment">- Check your program for recursive functions that are not tail-recursive
  Rewrite these in tail-recursive form.
- If you spawned this process in a small stack. For example (spawn 10 prg),
  try to spawn it with a larger stack.
</pre> <hr  />
<h2>division_by_zero</h2>
<p>The <code>division_by_zero</code> symbol is returned when dividing by zero. </p><pre class="fragment">- Check your math.
- Add 0-checks into your code at a strategic position.
</pre> <hr  />
<h2>variable_not_bound</h2>
<p>The <code>variable_not_bound</code> symbol is returned when evaluating a variable (symbol) that is neighter bound nor special (built-in function).</p>
<h1>Flash memory</h1>
<p>Flash memory can be used to store data and functions that are constant. Things can be moved to flash explicitly using the <code>move-to-flash</code> function or as part of the reading procedure. To move things automatically to flash during reading, there are <code>@</code>directives.</p>
<hr  />
<h2>@const-symbol-strings</h2>
<p>if <code>@const-symbol-strings</code> directive is placed in a file, symbols will be created in flash memory instead of the arrays memory.</p>
<hr  />
<h2>@const-start</h2>
<p><code>@const-start</code> opens a block of code where each global definition is moved to constant memory (flash) automatically. This can be used only together with the incremental reader (such as <code>read-eval-program</code>).</p>
<p>A <code>@const-start</code> opened block should be closed with a <code>@const-end</code>. Constant blocks cannot be nested.</p>
<p>Example:</p>
<div class="fragment"><div class="line">@const-start</div>
<div class="line"> </div>
<div class="line">(defun f (x) (+ x 1))  ; a function stored in constant memory</div>
<div class="line"> </div>
<div class="line">@const-end</div>
<div class="line"> </div>
<div class="line">(+ f 2)</div>
</div><!-- fragment --><hr  />
<h2>@const-end</h2>
<p><code>@const-end</code> closes an block opened by <code>@const-start</code>.</p>
<hr  />
<h2>move-to-flash</h2>
<p>A value can be moved to flash storage to save space on the normal evaluation heap or lbm memory. A <code>move-to-flash</code> expression is of the form <code>(move-to-flash sym opt-sym1 ... opt-symN)</code>. The symbols <code>sym</code>, <code>opt-sym1 ... opt-symN</code> should be globally bound to the values you want moved to flash. After the value has been moved, the environment binding is updated to point into flash memory. <b>CAUTION</b> This function should be used carefully. Ideally a value should be moved to flash immediately after it is created so there is no chance that other references to original value exists.</p>
<p>Example that moves an array to flash storage:</p>
<div class="fragment"><div class="line">(define a [1 2 3 4 5 6])</div>
<div class="line"> </div>
<div class="line">(move-to-flash a)</div>
</div><!-- fragment --><p>Example that moves a list to flash storage:</p>
<div class="fragment"><div class="line">(define ls &#39;(1 2 3 4 5))</div>
<div class="line"> </div>
<div class="line">(move-to-flash ls)</div>
</div><!-- fragment --><p>Functions can be moved to flash storage as well:</p>
<div class="fragment"><div class="line">(defun f (x) (+ x 1))</div>
<div class="line"> </div>
<div class="line">(move-to-flash f)</div>
</div><!-- fragment --><hr  />
<h1>Types</h1>
<h2>type-list</h2>
<hr  />
<h2>type-i</h2>
<p>A value with type <code>type-i</code> occupy 28bits on the 32 bit version of LBM and 56bits on the 64bit version.</p>
<hr  />
<h2>type-u</h2>
<p>A value with type <code>type-u</code> occupy 28bits on the 32 bit version of LBM and 56bits on the 64bit version.</p>
<hr  />
<h2>type-float</h2>
<hr  />
<h2>type-i32</h2>
<hr  />
<h2>type-u32</h2>
<hr  />
<h2>type-i64</h2>
<hr  />
<h2>type-u64</h2>
<hr  />
<h2>type-double</h2>
<hr  />
<h2>type-array</h2>
<hr  />
<h2>type-symbol</h2>
<hr  />
<h2>type-char</h2>
<hr  />
<h2>type-ref</h2>
<hr  />
<h2>type-channel</h2>
<hr  />
<h1>Type convertion functions</h1>
<h2>to-byte</h2>
<p>Convert any numerical value to a byte. If the input is not a number the output of this function will be 0.</p>
<hr  />
<h2>to-i</h2>
<p>Convert a value of any numerical type to an integer. The resulting integer is a 28bit value on 32bit platforms and 56 bits on 64 bit platforms. If the input is not a number the output of this function will be 0.</p>
<hr  />
<h2>to-u</h2>
<p>Convert a value of any numerical type to an unsigned integer. The resulting integer is a 28bit value on 32bit platforms and 56 bits on 64 bit platforms. If the input is not a number the output of this function will be 0.</p>
<hr  />
<h2>to-i32</h2>
<p>Convert any numerical value to a 32bit int. If the input is not a number the output of this function will be 0.</p>
<hr  />
<h2>to-u32</h2>
<p>Convert any numerical value to a 32bit unsigned int.</p>
<hr  />
<h2>to-float</h2>
<p>Convert any numerical value to a single precision floating point value. If the input is not a number the output of this function will be 0.</p>
<hr  />
<h2>to-i64</h2>
<p>Convert any numerical value to a 64bit int. If the input is not a number the output of this function will be 0.</p>
<hr  />
<h2>to-u64</h2>
<p>Convert any numerical value to a 64bit unsigned int. If the input is not a number the output of this function will be 0.</p>
<hr  />
<h2>to-double</h2>
<p>Convert any numerical value to a double precision floating point value. If the input is not a number the output of this function will be 0.</p>
<hr  />
 </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
